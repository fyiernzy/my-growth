---
updated: 2025-07-25T23:48:06.654+08:00
edited_seconds: 1087
---
当我在追求把代码写得优美的时候，常常会听到以下的话：
1. 你把代码写得那么好有什么用？你现在用的到吗？
2. 代码可以 Work 就好了，写得好还是不好，反正其他人都不知道。
3. 现在 AI 写的 Code 都可以比我们好了，你还再追求把 Code 写好有什么用？

老实说，追求写好代码在当下的确没什么用，毕竟费时费力，而且与人合作的时候，通常你也会延续旧有系统的风格，只能往屎山上叠屎；特别是在赶 DDL 的时候，追求整齐的代码风格 —— 比如命名统一、缩进统一、更改写法等 —— 就像在刚从深海出来的潜水员纠察他们的着装，肯定是要被骂的，毕竟当下最重要的任务便是 Make Things Work。

我也认同这一点：Make It Work, Make It Right, Make It Fast。当你做不出来东西的时候，说什么性能调优、代码重构都只是 Bullshit，你的客户并不关心代码好不好看、性能好不好这些事，他们只知道你做不出来东西。所以我们的第一要点永远是 Make It Work。可以参考以下视频： https://www.youtube.com/watch?v=Sju32NqjQUc&list=PLPLxoPV5SuZmrc-q6-lzzBBmUi656xXm6&index=12 

但等等，这难道说我们就不应该关心 Make It Right 和 Make It Fast 吗？不！只是这两者的优先级应该排在 Make It Work 之后而已。

那你问我：把代码写好有什么用？

我就说一个我自己感受最多的：你可以学习到很多新的知识。比如下面这个代码：

```java
public List<Student> getEligibleStudents() {
	List<Student> students = getStudentList();
	List<Student> eligibleStudents = new ArrayList<>();
	
	for(Student student : students) {
		if(student.isActiveStudent() && student.getCGPA() > 3.5) {
			eligibleStudents.add(student);
		}
	}
	
	Collections.sort(eligibleStudents)
	return eligibleStudents;
}
```

这个代码好吗？很难说，因为这很主观，但可以肯定的是：它一定没问题。但如果我想要进一步优化这个代码的话，我便会寻找相关的可能性，所以我便接触到了 Stream 的概念：

```java
public List<Student> getEligibleStudents() {
	return getStudentList().stream()
		       .filter(this::isEligible)
		       .sort()
		       .toList();
}

private boolean isEligible(Student student) {
	return student.isActiveStudent() && student.getCGPA() > 3.5;
}
```

第一次看到 Stream 的时候，我可谓是 “见猎心喜”，十分喜欢这样的写法。后来深入学习，便了解了 Declarative Programming 和 Imperative Programming，也了解了 Functional Programming 的 *Stateless* 和 *Side-Effect Free* 的特性。往下，我便会去思考 FP 和当下 for-if-return 的写法各有什么优缺，要怎么去使用才是最合适的。这提升了我对代码的理解能力，还有编写代码的能力。

再比如 Optional，第一次用的时候也是被它的能力给惊艳到了，价值就是随地大小 Optional，甚至于简单的检查也要用 Optional，如下：

```java
Optional.ofNullable(request)
	.orElseThrow(() -> new IllegalArgumentException());
```

但这难道就是最好的写法吗？后来接触到了 Google Guava 的 Validators，才了解到 Validators 的写法更简洁，而且也不会有因初始化 Optional 造成的开销，俨然成为我当下的最佳选择：

```java
// ❌ 我不喜欢
Optional.ofNullable(request)
	.orElseThrow(() -> new IllegalArgumentException());

// ✅ 我喜欢
Validators.nonNull(request);
```

关于 Error Handling 这个部分，可以看我另外一篇文章。甚至于简单的 Default Value 我也觉得要用自己的 Util 更好，如下：

```java
// ❌ 我不喜欢
Optional.ofNullable(value).orElseGet(() -> new Value());

// ✅ 我喜欢
ValueUtil.orElseGet(value, () -> new Value());
```

这倒也不是说 Optional 一无是处，我觉得它真正强力的部分是需要获得 Chain Value 的时候，如下：

```java
// ❌ 我不喜欢
if(student != null) {
	if(student.getResult() != null) {
		if(student.getResult().getMathResult() != null) {
			// ... 难道你还有一直 if 下去吗...
		}
	}
}

// ✅ 我喜欢
MathResult mathResult = Optional.ofNullable(student)
							.map(Student::getResult)
							.map(Result::getMathResult)
							.orElse(null);
```

但如果你没有想要进一步的追求，停留在 “能 Work 就好” 的阶段的话，你还会学到这些 

我觉得代码就是自己的 “信誉证明”。