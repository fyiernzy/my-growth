---
updated: 2025-07-26T00:40:56.593+08:00
edited_seconds: 2796
---
当我在追求把代码写得优美的时候，常常会听到以下的话：
1. 你把代码写得那么好有什么用？你现在用的到吗？
2. 代码可以 Work 就好了，写得好还是不好，反正其他人都不知道。
3. 现在 AI 写的 Code 都可以比我们好了，你还再追求把 Code 写好有什么用？

老实说，追求写好代码在当下的确没什么用，毕竟费时费力，而且与人合作的时候，通常你也会延续旧有系统的风格，只能往屎山上叠屎；特别是在赶 DDL 的时候，追求整齐的代码风格 —— 比如命名统一、缩进统一、更改写法等 —— 就像在刚从深海出来的潜水员纠察他们的着装，肯定是要被骂的，毕竟当下最重要的任务便是 Make Things Work。

我也认同这一点：Make It Work, Make It Right, Make It Fast。当你做不出来东西的时候，说什么性能调优、代码重构都只是 Bullshit，你的客户并不关心代码好不好看、性能好不好这些事，他们只知道你做不出来东西。所以我们的第一要点永远是 Make It Work。可以参考以下视频： https://www.youtube.com/watch?v=Sju32NqjQUc&list=PLPLxoPV5SuZmrc-q6-lzzBBmUi656xXm6&index=12 

但等等，这难道说我们就不应该关心 Make It Right 和 Make It Fast 吗？不！只是这两者的优先级应该排在 Make It Work 之后而已。

那你问我：把代码写好有什么用？

我就说一个我自己感受最多的：你可以学习到很多新的知识。比如下面这个代码：

```java
public List<Student> getEligibleStudents() {
	List<Student> students = getStudentList();
	List<Student> eligibleStudents = new ArrayList<>();
	
	for(Student student : students) {
		if(student.isActiveStudent() && student.getCGPA() > 3.5) {
			eligibleStudents.add(student);
		}
	}
	
	Collections.sort(eligibleStudents)
	return eligibleStudents;
}
```

这个代码好吗？很难说，因为这很主观，但可以肯定的是：它一定没问题。但如果我想要进一步优化这个代码的话，我便会寻找相关的可能性，所以我便接触到了 Stream 的概念：

```java
public List<Student> getEligibleStudents() {
	return getStudentList().stream()
		       .filter(this::isEligible)
		       .sort()
		       .toList();
}

private boolean isEligible(Student student) {
	return student.isActiveStudent() && student.getCGPA() > 3.5;
}
```

第一次看到 Stream 的时候，我可谓是 “见猎心喜”，十分喜欢这样的写法。后来深入学习，便了解了 Declarative Programming 和 Imperative Programming，也了解了 Functional Programming 的 *Stateless* 和 *Side-Effect Free* 的特性。往下，我便会去思考 FP 和当下 for-if-return 的写法各有什么优缺，要怎么去使用才是最合适的。这提升了我对代码的理解能力，还有编写代码的能力。

再比如 Optional，第一次用的时候也是被它的能力给惊艳到了，价值就是随地大小 Optional，甚至于简单的检查也要用 Optional，如下：

```java
Optional.ofNullable(request)
	.orElseThrow(() -> new IllegalArgumentException());
```

但这难道就是最好的写法吗？后来接触到了 Google Guava 的 Validators，才了解到 Validators 的写法更简洁，而且也不会有因初始化 Optional 造成的开销，俨然成为我当下的最佳选择：

```java
// ❌ 我不喜欢
Optional.ofNullable(request)
	.orElseThrow(() -> new IllegalArgumentException());

// ✅ 我喜欢
Validators.nonNull(request);
```

关于 Error Handling 这个部分，可以看我另外一篇文章。甚至于简单的 Default Value 我也觉得要用自己的 Util 更好，如下：

```java
// ❌ 我不喜欢
Optional.ofNullable(value).orElseGet(() -> new Value());

// ✅ 我喜欢
ValueUtil.orElseGet(value, () -> new Value());
```

这倒也不是说 Optional 一无是处，我觉得它真正强力的部分是需要获得 Chain Value 的时候，如下：

```java
// ❌ 我不喜欢
if(student != null) {
	if(student.getResult() != null) {
		if(student.getResult().getMathResult() != null) {
			// ... 难道你还有一直 if 下去吗...
		}
	}
}

// ✅ 我喜欢
MathResult mathResult = Optional.ofNullable(student)
							.map(Student::getResult)
							.map(Result::getMathResult)
							.orElse(null);
```

但如果你没有想要进一步的追求，停留在 “能 Work 就好” 的阶段的话，你还会学到 Optional 的写法吗？你会了解为什么要用 Optional 吗？为什么 Java 要引入 Optional？它本来是为了解决什么问题的？其他编程语言是怎么处理类似问题的？我们要怎么正确合理地使用它 —— 这些问题，只有当你去追求把代码写好的时候，你才会去了解。了解的越多，看代码的视野越宽广，自然更容易理解不同写法的优劣，才知道什么是好的，什么是不好的。

而且，这也不过是”优秀代码“ 的冰山一角。要写好代码，还得思考这代码会不会有潜在的 Bug、会不会导致性能问题等。如果你去深入了解这些问题，那你就可以更了解造成 Bug 或性能问题的原因，那往后你就更可能更轻松地解决问题，或者避免类似错漏，而这样的见解在软件公司内大多也是可迁移的（Transferable）的。我称之为可迁移的软体工程师的能力。

其次是，我认为代码就是自己的 “信誉证明”。代码写的差，大家就会认为你技术不行；你写的好，大家自然会对你更加信服。虽然一个人的能力好不好不应该通过代码去判断，但是代码写的好的人总是加分。虽然已经有人调侃 Code is Cheap, Show me your Prompt，但是你没写过好的代码，不追求好的代码，那你给 AI 的代码大抵也不会好到哪里去，AI 给你的代码也大概会是烂的 —— 毕竟 Garbage In Garbage Out 嘛（笑。老实说，我认为对代码的追求也可以影响、吸引有相同志趣的人，互相学习、互相成长。

第三便是隐性知识。在追求更好的代码 —— 比如代码规范（Coding Style）、设计模式（Design Pattern）和架构（Architecture）的时候，我们会在培养自己的品味（Taste）的同时，也会沉淀自己的思考和偏好。比如下面的缩进：

```java
// 写法 1
MathResult mathResult = Optional.ofNullable(student)
							.map(Student::getResult)
							.map(Result::getMathResult)
							.orElse(null);

// 写法 2
MathResult mathResult = Optional.ofNullable(student)
	.map(Student::getResult)
	.map(Result::getMathResult)
	.orElse(null);

// 写法 3
MathResult mathResult = 
	Optional.ofNullable(student)
		.map(Student::getResult)
		.map(Result::getMathResult)
		.orElse(null);
```

对你来说，哪一个比较好呢？为什么？我自己的选择会是 1，因为 `.map()` 和 `.orElse()` 和 `Optional.ofNullable(student)` 在逻辑上应该是相同的，因此应该排在一起；而我认为 `Optional` 应该和 `MathResult` 同排，符合大多数人 Variable = Assignment 的思维。这便是在磨练我们的隐性知识了，这也是区分小白和高手的一个特征。就更别说那些有意识去运用设计模式，并且注重架构设计的人了 —— 他们对重构、元素之间的关系、API 使用难易度等都会有更加深入的了解。这些经验和 “无法言说” 的知识，正是程序员的重要财富，也是程序员在 AI 时代的一个核心优势。之后当你在写代码的时候，你自然而然会考虑许多因素，甚至你都察觉不到你已经淘汰了那些不太合适的选项，只在较合适的选项里进行下一步思考。

第四便是可迁移（Transferable）、可复用（Reusability）。对于优秀代码的思考和追求（不仅是代码风格，还有避免坏味道（Code Smell）、避免安全和性能问题等），是可以运用在其他时候的，如上面所说。这次用不到，兴许下次便用到了呢？这样的话，你不就已经有了现成的、优秀的、可直接复制粘贴的解决方法吗？这不就提升了效率吗？

第五便是未来迭代。当我们形成了当下的认知和理解后，我们便有了基础。当我们遇见其他人的代码的时候，我们就可以做出比较 —— 什么部分比较好，我可以学习优化；什么部分比较差，我可得避免避免，这便是别人说的，取其精华，去其糟粕。所谓 ”博众家之长“，看多了、比较多了，你也会知道各个设计的优缺，便也积累了各种各样的解决方案，可以用来解决各种各样不同场景的问题，那你解决问题的能力不就提升了吗？程序员的成长不就是如此吗？如果没有思考，只停留在 ”能用“ 的水准，那我们在面对复杂问题的时候，我们只会找出 ”当下能解决问题“ 的方案，却可能顾此失彼，也无法了解这个方案的限制和优势。

总的来说，代码写的好，对当前项目不一定有用，但可以一定程度上对抗项目的熵增，使项目在交付之前不至于全面崩盘，也使日后的维护变得容易，这是其一；其二，把代码写的好，也能夯实基本功，提高程序设计能力，积累个人信誉。其三，当你不行的时候，AI 给你的答案通常也不行；反之，则可能给你意想不到的惊喜，这也便是 AI 时期的马太效应。

