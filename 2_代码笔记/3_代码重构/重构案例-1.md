```java
public class CardApplicationServiceImpl implements CardApplicationService {

    public void addCard(
	    CardOrderRequestModel cardOrderRequestModel, 
		AuditTrailClientModel auditTrailClientModel
	) {        
        String accountNo = cardOrderRequestModel.getAccountNo();
        Long cardPaymentId = cardOrderRequestModel.getCardPaymentId();
        String cardHolderName = cardOrderRequestModel.getCardHolderName();
        int numberOfCards = 0;
        List<String> newCardIdList = new ArrayList<>();
        List<String> requestedCardTypeList = new ArrayList<>();

        for (CardRequestModel cardRequestModel : cardOrderRequestModel.getRequestCards()) {
            numberOfCards += 1;
            // TODO: get account model, temporarily use data generator
            AccountModel accountModel = generateRandomAccountModel(accountNo);

            // TODO: use account model to get user's residential address, temporarily use data generator
            AddressModel residentialAddress = generateRandomAddress();

            addressModelValidator.validate(residentialAddress);

            ProductCardBean productCardBean = productCardService.getProductCard(cardRequestModel.getCardCategory(),
                    cardRequestModel.getCardType(), cardRequestModel.getPaymentNetwork(), cardRequestModel.getProductCardId());

            // TODO: Use account service to get product account id
            if (!accountModel.getProductAccountId().equals(productCardBean.getProductAccountId())) {
                throw new CardException(CardErrorEnum.INVALID_PRODUCT_FOR_PRODUCT_ACCOUNT);
            }

            // TODO: Use product account service to get product account name
            // temporary usage
            String productAccountName = "premium";

            switch (productAccountName) {
                // temporary use text here, will change to account constant value
                case "standard" -> orderStandardCard(
                        accountModel, cardRequestModel, residentialAddress, cardPaymentId, cardHolderName, auditTrailClientModel
                );
                // temporary use text here, will change to account constant value
                case "premium" -> orderPremiumCard(
                        accountModel, cardRequestModel, residentialAddress, cardPaymentId, cardHolderName, numberOfCards, newCardIdList, requestedCardTypeList, auditTrailClientModel
                );
                default -> throw new CardException(CardErrorEnum.UNKNOWN_PRODUCT_ACCOUNT_TYPE);
            }
        }
    }

    // To activate physical card
    @Override
    @Transactional
    public void activatePhysicalCard(ActivatePhysicalCardRequestModel activatePhysicalCardRequestModel, AuditTrailClientModel auditTrailClientModel) {
        try {
            activatePhysicalCardRequestModelValidator.validate(activatePhysicalCardRequestModel);
            String accountNo = activatePhysicalCardRequestModel.getAccountNo();
            String cardId = activatePhysicalCardRequestModel.getCardId();
            ViewAccountCardDetailsBean cardBean = cardGeneralService.getViewClientCardDetailsBean(cardId);
            IPayActivateCardRequestModel iPayActivateCardRequestModel = new IPayActivateCardRequestModel();
            iPayActivateCardRequestModel.setRemark(CardConstant.REMARK_ACTIVATE_CARD);

            // TODO: Set Card Pin on IPAY

            // TODO: activateIpayCard through Ipay service
            // activateIpayCard(viewClientCardDetailsBean, iPayActivateCardRequestModel);

            // update card status to activated
            CardBean card = cardGeneralService.getCardBean(cardId);
            card.setStatus(CardStatusEnum.ACTIVATED);
            card.setActivationDate(OffsetDateTime.now(DEFAULT_OFFSET_ZONE));
            cardDao.save(card);
            cardDao.flush();

            // update application status to shipped once activated
            CardApplicationUpdateModel cardApplicationUpdateModel = new CardApplicationUpdateModel();
            cardApplicationUpdateModel.setProductCardId(cardBean.getProductCardId());
            cardApplicationUpdateModel.setCardShippingStatus(CardShippingStatusEnum.SHIPPED.toValue());
            cardApplicationUpdateModel.setCardStatus(ConvertedCardStatusEnum.ACTIVATED.toValue());
            updateCardApplication(accountNo, cardApplicationUpdateModel, false);

            // TODO: Send success notification

        } catch (Exception e) {
            // TODO: Send failed notification
            throw e;
        } finally {
            auditTrailClientModel.getAuditContext()
                    .put("accountNo", activatePhysicalCardRequestModel.getAccountNo());
            auditTrailClientModel.getAuditContext()
                    .put("cardId", activatePhysicalCardRequestModel.getCardId());
        }
    }

    // To get card application and shipping history record
    @Override
    @Transactional(readOnly = true)
    public CardApplicationAndTrackingResponseModel getCardApplicationAndTracking(GetCardApplicationAndTrackingRequestModel getCardApplicationAndTrackingRequestModel) {
        getCardApplicationAndTrackingRequestModelValidator.validate(getCardApplicationAndTrackingRequestModel);
        String accountNo = getCardApplicationAndTrackingRequestModel.getAccountNo();
        CardApplicationAndTrackingResponseModel cardApplicationAndTrackingResponseModel = new CardApplicationAndTrackingResponseModel();
        cardApplicationAndTrackingResponseModel.setCardApplicationModel(getCardApplicationDetails(accountNo));
        List<CardShippingHistoryModel> cardShippingHistoryModelList = cardApplicationQuery.getCardShippingHistoryModelListByAccountNo(accountNo);
        cardApplicationAndTrackingResponseModel.setCardShippingHistoryModelList(cardShippingHistoryModelList);
        return cardApplicationAndTrackingResponseModel;
    }

    // To get shipping detail (status, estimated time for start and end, isFirstTimeOrder)
    @Override
    public ShippingDetailsResponseModel getShippingDetails(GetShippingDetailsRequestModel getShippingDetailsRequestModel) {
        getShippingDetailsRequestModelValidator.validate(getShippingDetailsRequestModel);
        String accountNo = getShippingDetailsRequestModel.getAccountNo();
        Long productCardId = getShippingDetailsRequestModel.getProductCardId();
        ShippingDetailsResponseModel shippingDetailsResponseModel = new ShippingDetailsResponseModel();
        ViewAccountCardDetailsBean viewAccountCardDetailsBean = cardGeneralService.findCardInUse(accountNo, productCardId);

        if (ObjectUtils.isNotEmpty(viewAccountCardDetailsBean)) {
            CardShippingBean cardShippingBean = cardGeneralService.getCardShippingBean(viewAccountCardDetailsBean.getCardApplicationId());

            shippingDetailsResponseModel.setShippingStatus(viewAccountCardDetailsBean.getShippingStatus().toValue());
            // only return date if status = shipping
            if (ObjectUtils.isNotEmpty(cardShippingBean) && CardShippingStatusEnum.SHIPPING.equals(cardShippingBean.getStatus())) {
                shippingDetailsResponseModel.setEstimatedArrivalStartDate(cardShippingBean.getEstimatedArrivalStartDate());
                shippingDetailsResponseModel.setEstimatedArrivalEndDate(cardShippingBean.getEstimatedArrivalEndDate());
            }
        }

        // check if have existing terminated physical card
        ViewAccountCardDetailsBean terminatedViewCardDetailsBean = cardGeneralService.findLatestTerminatedCard(accountNo, productCardId);

        if (terminatedViewCardDetailsBean == null) {
            shippingDetailsResponseModel.setIsFirstTimeOrder(true);
        } else {
            shippingDetailsResponseModel.setIsFirstTimeOrder(false);

            // check if the card in use is empty, if empty check if the terminated reason is returned/gone
            if (viewAccountCardDetailsBean == null && CardShippingStatusEnum.RETURNED_GONE.equals(terminatedViewCardDetailsBean.getShippingStatus())) {
                shippingDetailsResponseModel.setShippingStatus(terminatedViewCardDetailsBean.getShippingStatus().toValue());
            }
        }

        return shippingDetailsResponseModel;
    }

    // To validate card pin format before activation
    

    @Override
    public List<CardApplicationInfoModel> findCardApplicationList(GetExistingCardApplicationRequestModel getExistingCardApplicationRequestModel) {
        getExistingCardApplicationRequestModelValidator.validate(getExistingCardApplicationRequestModel);

        return cardApplicationDao
                .findCardApplicationBeanByAccountNo(getExistingCardApplicationRequestModel.getAccountNo())
                .filter(list -> !list.isEmpty())
                .orElse(Collections.emptyList())
                .stream()
                .map(cardMapper::mapCardApplicationBeanToModel)
                .toList();
    }


    private void updateCardApplication(String accountNo, CardApplicationUpdateModel cardApplicationUpdateModel, boolean isSystem) {
        CardApplicationBean cardApplicationBean = cardGeneralService.getCardApplicationBean(accountNo, cardApplicationUpdateModel.getProductCardId(), CardApplicationStatusEnum.COMPLETED);
        CardShippingBean cardShippingBean = cardGeneralService.getCardShippingBean(cardApplicationBean.getId());
        CardBean cardBean = cardGeneralService.getCardBean(cardApplicationBean.getId());
        ViewAccountCardDetailsBean viewAccountCardDetailsBean = cardGeneralService.getViewClientCardDetailsBean(cardBean.getId());

        String newShippingStatus = cardApplicationUpdateModel.getCardShippingStatus();

        if (StringUtils.equals(newShippingStatus, cardShippingBean.getStatus().toValue())) {
            return;
        }

        CardShippingStatusEnum shippingStatus = baseEnumMapper.toEnum(newShippingStatus, CardShippingStatusEnum.class);

        // Use for update card shipping status API
        String cardStatus;
        if (ObjectUtils.isNotEmpty(cardApplicationUpdateModel.getCardStatus())) {
            cardStatus = cardApplicationUpdateModel.getCardStatus();
        } else {
            cardStatus = viewAccountCardDetailsBean.getConvertedCardStatus().toValue();
        }
        CardStatusEnum currentCardStatus = baseEnumMapper.toEnum(cardStatus, CardStatusEnum.class);

        cardShippingBean.setStatus(shippingStatus);
        cardShippingBean.setUpdatedBy(isSystem ? SharedConstant.SYSTEM : accountNo);
        cardShippingDao.save(cardShippingBean);
        cardShippingDao.flush();

        OffsetDateTime shippingStatusDate = cardShippingBean.getUpdatedDate() != null
                ? cardShippingBean.getUpdatedDate()
                : cardShippingBean.getCreatedDate();

        CardShippingHistoryBean cardShippingHistoryBean = cardMapper.toCardShippingHistoryBean(cardApplicationBean.getId(), cardShippingBean, accountNo, shippingStatusDate);
        cardShippingHistoryBean.setCardStatus(currentCardStatus);
        cardShippingHistoryDao.save(cardShippingHistoryBean);

        if (Objects.equals(CardShippingStatusEnum.RETURNED_GONE, shippingStatus)) {
            // TODO: terminate card
            // TODO: send notification to inform card terminated

        } else if (Objects.equals(CardShippingStatusEnum.SHIPPING, shippingStatus)) {
            // TODO: send notification to inform estimated time
        }
    }

    private CardShippingTypeEnum getShippingType(String countryCode) {
        if (CardConstant.ACCEPTED_COUNTRY_CODES.contains(countryCode)) {
            return CardShippingTypeEnum.DOMESTIC;
        } else {
            throw new CardException(CardErrorEnum.INVALID_DELIVERY_ADDRESS);
        }
    }

    private String createCardApplicationAndCard(AccountModel accountModel, CardRequestModel cardRequestModel, AddressModel mailingAddress, Long cardPaymentId, String cardHolderName) {
        // TODO: Add Ipay card
        IPayCardModel iPayCardModel = createRandomIPayCardModel();

        CardApplicationBean cardApplicationBean = buildCardApplication(
                accountModel, cardRequestModel, iPayCardModel.getCardOrderId(),
                CardApplicationStatusEnum.COMPLETED.toValue(), cardPaymentId, cardHolderName
        );

        String newCardId = null;
        if (cardRequestModel.getCardType().equalsIgnoreCase(PHYSICAL)) {
            newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), accountModel.getAccountNo(), cardApplicationBean.getCardApplicantName(), CardStatusEnum.INACTIVE, PHYSICAL);
        } else {
            newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), accountModel.getAccountNo(), cardApplicationBean.getCardApplicantName(), CardStatusEnum.ACTIVATED, VIRTUAL);
        }

        if (ObjectUtils.isNotEmpty(mailingAddress)) {
            createShippingRecords(cardApplicationBean, mailingAddress, accountModel.getAccountNo());
        }
        return newCardId;
    }

    private CardApplicationBean buildCardApplication(AccountModel accountModel, CardRequestModel cardRequestModel, String cardOrderId, String status, Long cardPaymentId, String cardHolderName) {
        // Create the CardApplicationBean using the mapper
        CardApplicationBean cardApplicationBean = cardMapper.toCardApplicationBean(cardRequestModel, cardPaymentId, accountModel.getAccountNo(),
                cardOrderId, status, cardHolderName);

        // Save info to db
        return cardApplicationDao.save(cardApplicationBean);
    }

    private void createPendingCardApplication(AccountModel accountModel, Long cardPaymentId, CardRequestModel cardRequestModel, String cardHolderName) {
        CardApplicationBean cardApplicationBean = cardMapper.toCardApplicationBean(
                cardRequestModel,
                cardPaymentId,
                accountModel.getAccountNo(),
                null,
                CardApplicationStatusEnum.PENDING.toValue(),
                cardHolderName
        );
        cardApplicationDao.save(cardApplicationBean);
    }

    private void createShippingRecords(CardApplicationBean cardApplicationBean, AddressModel mailingAddress, String accountNo) {
        CardShippingRequestModel shippingRequest = new CardShippingRequestModel();
        shippingRequest.setDeliveryAddress(mailingAddress);

        CardShippingTypeEnum shippingType = getShippingType(mailingAddress.getCountryCode());
        OffsetDateTime estimatedArrivalStartDate = OffsetDateTime.now(DEFAULT_OFFSET_ZONE).plusDays(CardConstant.ESTIMATED_ARRIVAL_START_INCREMENT);
        OffsetDateTime estimatedArrivalEndDate = OffsetDateTime.now(DEFAULT_OFFSET_ZONE).plusDays(CardConstant.ESTIMATED_ARRIVAL_END_INCREMENT);
        CardShippingBean shippingBean = cardMapper.toCardShippingBean(
                cardApplicationBean.getId(), shippingRequest, accountNo,
                CardShippingStatusEnum.PENDING_TO_SHIP.toValue(),
                estimatedArrivalStartDate, estimatedArrivalEndDate
        );
        ProductCardLogisticBean logistic = cardGeneralService.getLogistic(shippingType);
        shippingBean.setLogistic(logistic);
        shippingBean.setProductCardLogisticId(logistic.getId());
        shippingBean.setCountryCode(SharedConstant.DEFAULT_COUNTRY_CODE);
        cardShippingDao.save(shippingBean);
        cardShippingDao.flush();

        OffsetDateTime shippingStatusDate = shippingBean.getUpdatedDate() != null
                ? shippingBean.getUpdatedDate()
                : shippingBean.getCreatedDate();

        CardShippingHistoryBean history = cardMapper.toCardShippingHistoryBean(
                cardApplicationBean.getId(), shippingBean, accountNo, shippingStatusDate
        );
        history.setCardStatus(CardStatusEnum.INACTIVE);
        cardShippingHistoryDao.save(history);
    }

    @Override
    @Transactional
    public void confirmCard(ConfirmCardRequestModel confirmCardRequestModel) {
        confirmCardRequestModelValidator.validate(confirmCardRequestModel);
        List<String> cardTypeList = new ArrayList<>();
        List<String> newCardIdList = new ArrayList<>();
        String accountNo = confirmCardRequestModel.getAccountNo();

        try {
            // TODO: Use account model to get user's mail address
//        AccountBean accountRecord = accountService.getAccountByAccountNo(accountNo);
//        AddressModel mailingAddress = new AddressModel();
//        mailingAddress.setAddressLine1(accountRecord.getMailAddress1);
//        mailingAddress.setAddressLine2(accountRecord.getMailAddress2);
//        mailingAddress.setCountryCode(accountRecord.getMailCountryCode);
//        mailingAddress.setState(accountRecord.getMailState);
//        mailingAddress.setPostalCode(accountRecord.getMailZip);
//        mailingAddress.setCity(accountRecord.getMailTown);
            AddressModel mailingAddress = generateRandomAddress();
            // temporarily address
            CardShippingRequestModel cardShippingRequestModel = new CardShippingRequestModel();
            cardShippingRequestModel.setDeliveryAddress(mailingAddress);

            // Validate mailing address
            addressModelValidator.validate(cardShippingRequestModel.getDeliveryAddress());

            for (Long cardApplicationId : confirmCardRequestModel.getCardApplicationIds()) {
                CardApplicationBean cardApplicationBean = cardGeneralService.getCardApplicationBean(cardApplicationId);
                cardApplicationBean.setStatus(CardApplicationStatusEnum.COMPLETED);

                ProductCardBean productCardBean = productCardService.getProductCard(cardApplicationBean.getProductCardId());

                // TODO: get ipay customer id through account service
                //String customerId = accountModel.getIpayCustomerId();

                // TODO: add card to ipay
                // IPayCardModel iPayCardModel = addIpayCard(accountModel, customerId);
                // fake data generator
                IPayCardModel iPayCardModel = createRandomIPayCardModel();
                cardApplicationBean.setCardOrderId(iPayCardModel.getCardOrderId());
                cardApplicationDao.save(cardApplicationBean);

                String newCardId;
                String cardType = productCardBean.getCardType();

                if (productCardBean.getCardType().equalsIgnoreCase(PHYSICAL)) {
                    newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), accountNo, cardApplicationBean.getCardApplicantName(), CardStatusEnum.INACTIVE, PHYSICAL);
                    createShippingRecords(cardApplicationBean, cardShippingRequestModel.getDeliveryAddress(), accountNo);
                } else {
                    newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), cardApplicationBean.getAccountNo(), cardApplicationBean.getCardApplicantName(), CardStatusEnum.ACTIVATED, VIRTUAL);
                }

                if (newCardId != null) {
                    newCardIdList.add(newCardId);
                }
                cardTypeList.add(cardType);

                //TODO: send success notification
            }

            String joinedCardTypes = String.join(CardConstant.AND, cardTypeList);
            String joinedCardIds = newCardIdList.isEmpty() ? SharedConstant.DASH : String.join(SharedConstant.COMMA, newCardIdList);

            log.info("[CONFIRM_CARD] response: {} card(s) [{}] with ID: {} owned by user with Account No {} is created.",
                    cardTypeList.size(), joinedCardTypes, joinedCardIds, accountNo);


        } catch (Exception e) {
            //TODO: send fail notification
            throw e;
        }
    }

    //<--------Start: Data generator------------>
    private static AccountModel generateRandomAccountModel(String accountNo) {
        AccountModel accountModel = new AccountModel();

        // Generate random Account No
        accountModel.setAccountNo(accountNo);

        // Generate random NRIC Name
        accountModel.setNricName(generateRandomString());

        // Generate random First Name
        accountModel.setFirstName(generateRandomString());

        // Generate random Last Name
        accountModel.setLastName(generateRandomString());

        accountModel.setProductAccountId(2L);
        accountModel.setDateOfBirth(OffsetDateTime.parse("2022-12-05T16:00:00+08:00"));

        return accountModel;
    }

    private static AddressModel generateRandomAddress() {
        AddressModel addressModel = new AddressModel();

        // Random Address details
        addressModel.setAddressLine1(generateRandomString());
        addressModel.setAddressLine2(generateRandomString());
        addressModel.setState(generateRandomString());
        addressModel.setCity(generateRandomString());
        addressModel.setPostalCode(generateRandomPostalCode());
        addressModel.setCountryCode("MY");

        return addressModel;
    }


    private void setRemainingCardBean(CardBean cardBean, IPayCardModel iPayCardModel, String cardType) {
        String cardId = sequenceService.generateSerialNumber(SequenceConstant.SequenceEnum.CARD_ID_SEQ);
        OffsetDateTime expiryDate = ipayExpiryDateToOffsetDateTime(iPayCardModel.getCardExpiry());
        if (StringUtils.equalsIgnoreCase(CardConstant.VIRTUAL, cardType)) {
            cardMapper.updateCardBeanWithRemainingFields(cardBean, cardId, expiryDate, false, false, false, OffsetDateTime.now(DEFAULT_OFFSET_ZONE));
        } else if (StringUtils.equalsIgnoreCase(CardConstant.PHYSICAL, cardType)) {
            cardMapper.updateCardBeanWithRemainingFields(cardBean, cardId, expiryDate, true, false, true, null);
        }
    }

    private OffsetDateTime ipayExpiryDateToOffsetDateTime(String dateString) {
        // TODO: Identiffy what timezone the ipay date return, cause when they send their date, it may be different timezone
        SimpleDateFormat formatter = new SimpleDateFormat(CardConstant.IPAY_DATE_FORMAT_YYYYMM);
        formatter.setTimeZone(TimeZone.getTimeZone(SharedConstant.DEFAULT_TIMEZONE));

        try {
            // Parse to Date
            Date parsedDate = formatter.parse(dateString);

            // Use Calendar in UTC to avoid time zone shift
            Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(SharedConstant.DEFAULT_TIMEZONE));
            cal.setTime(parsedDate);
            cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
            cal.set(Calendar.HOUR_OF_DAY, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MILLISECOND, 0);

            // Convert to OffsetDateTime in UTC
            return convertDateToOffsetDateTime(cal.getTime());
        } catch (ParseException e) {
            return null;
        }
    }

    private OffsetDateTime convertDateToOffsetDateTime(Date date) {
        return date.toInstant().atOffset(DEFAULT_OFFSET_ZONE);
    }

    private CardApplicationModel getCardApplicationDetails(String accountNo) {
        List<ViewAccountCardDetailsBean> viewClientCardDetailsBeanList = cardGeneralService.findLatestViewAccountCardDetailsBeanForEachCardType(accountNo);
        if (CollectionUtils.isEmpty(viewClientCardDetailsBeanList)) {
            return null;
        }
        ViewAccountCardDetailsBean physicalCard = viewClientCardDetailsBeanList.stream().filter(e -> StringUtils.equals(CardConstant.PHYSICAL, e.getCardType())).findFirst().orElse(null);
        if (physicalCard == null) {
            return null;
        }

        CardApplicationBean cardApplicationBean = cardGeneralService.getCardApplicationBean(physicalCard.getCardApplicationId());
        CardShippingBean cardShippingBean = cardGeneralService.getCardShippingBean(physicalCard.getCardApplicationId());
        return cardMapper.mapCardApplicationAndCardShippingBeanToModel(cardApplicationBean, cardShippingBean, physicalCard.getCardId());
    }
    
```


## Complicated Boolean Condition
---
```java
public boolean validateCardPin(
	ValidateCardPinRequestModel validateCardPinRequestModel) {

	String pin = validateCardPinRequestModel.getPin();
	String accountNo = validateCardPinRequestModel.getAccountNo();
	String decryptedPin = getDecryptedJsonString(pin);

	if (decryptedPin == null || decryptedPin.length() != CardConstant.PIN_LENGTH || !decryptedPin.matches("\\d{6}")) {
		return false;
	}

	AccountModel accountModel = generateRandomAccountModel(accountNo);

	if (decryptedPin.chars().distinct().count() == 1 ||                 
			accountNo.contains(decryptedPin) ||                          
			(StringUtils.isNotBlank(accountModel.getIpayCustomerId()) &&
					accountModel.getIpayCustomerId().contains(decryptedPin)) ||
			isSequential(decryptedPin) ||
			matchesDobPattern(decryptedPin, accountModel)) {
		return false;
	}

	// If all checks pass, return true
	return true;
}

private boolean isSequential(String pin) {
	for (int i = 0; i < pin.length() - 1; i++) {
		int curr = Character.getNumericValue(pin.charAt(i));
		int next = Character.getNumericValue(pin.charAt(i + 1));
		if ((next != (curr + 1) % 10) && (next != (curr + 9) % 10)) {
			return false;
		}
	}
	return true;
}

private boolean matchesDobPattern(String pin, AccountModel accountModel) {
        String year = String.format("%04d", accountModel.getDateOfBirth().getYear());
        String month = String.format("%02d", accountModel.getDateOfBirth().getMonthValue());
        String day = String.format("%02d", accountModel.getDateOfBirth().getDayOfMonth());

        String pattern1 = year.substring(2) + month + day;
        String pattern2 = month + day + year.substring(2);
        String pattern3 = day + month + year.substring(2);
        String pattern4 = year + month.charAt(0) + day.charAt(0);
        String pattern5 = year.substring(2) + month + day.charAt(0);

        return pin.equals(pattern1) || pin.equals(pattern2) || pin.equals(pattern3)
                || pin.equals(pattern4) || pin.equals(pattern5);
    }
}
```

The main problem of this code snippet is that the boolean condition is extremely inexpressive, plus that it is way too complicated. This will make testing be harder as well. To refactor it, we should assign each condition to a suitable variable name, or using Guard statement.

```java
public boolean validateCardPin(
	ValidateCardPinRequestModel validateCardPinRequestModel) {

	String pin = validateCardPinRequestModel.getPin();
	String accountNo = validateCardPinRequestModel.getAccountNo();
	String decryptedPin = getDecryptedJsonString(pin);

	boolean isValidDecryptedPin = 
		decryptedPin != null 
			&& decryptedPin.length() == CardConstant.PIN_LENGTH
			&& decryptedPin.matches("\\d{6}");

	if(!isValidDecryptedPin) {
		return false;
	}

	AccountModel accountModel = generateRandomAccountModel(accountNo);

	boolean isAllSameValue = decryptedPin.chars().distinct().count() == 1;
	boolean isAccountContainsDecryptedPin = accountNo.contains(decryptedPin);
	boolean isCustomerIdContainsDecryptedPin = Optional.ofNullable(accountModel)
	.map(AccountModel::getIpayCustomerId)
	.orElse(false)
	.map(id -> id.contains(decryptedPin));
	boolean isPinSequential = isSequential(decryptedPin);
	boolean isPinMatchesDobPattern(decryptedPin, accountModel);

	if (  ||
			isSequential(decryptedPin) ||
			matchesDobPattern(decryptedPin, accountModel)) {
		return false;
	}

	// If all checks pass, return true
	return true;
	return !(isAllSameDigit 
		|| isAccountContainsDecryptedPin
		|| isCustomerIdContainsDecryptedPin
		|| isPinSequential
		|| isPinMatchesDobPattern
	);
}
```

Now, the main logic looks better. But is there anyway to enhance it further?

```java
public boolean validateCardPin(ValidateCardPinRequestModel request) {
	// 1. Obtain the value from the request
	if(request == null) {
		return false;
	}
	
	String pin = request.getPin();
	String accountNo = request.getAccountNo();
	String decryptedPin = request(pin);

	// 2. If the decryptedPin has wrong format, return false
	if(!isValidPinFormat(decryptedPin)) {
		return false;
	}

	// 3. Check if the pin conforms to the rules
	AccountModel account = generateRandomAccountModel(accountNo);
	return account != null && !isWeakPin(decryptedPin, accountNo, account);
}

private boolean isValidPinFormat(String pin) {
	return pin != null && pin.matches("\\d{6}");
}

private boolean isWeakPin(String pin, String accountNo, AccountModel account) {
    return isAllSameDigit(pin) 
		    || StringUtils.contains(accountNo, pin)
		    || customerIdContainsPin(account, pin)
		    || isSequential(pin)
		    || matchesDobPattern(pin, account);
}

private boolean isAllSameDigit(String pin) {
    return pin.chars().distinct().count() == 1;
}

private boolean customerIdContainsPin(AccountModel account, String pin) {
    return Optional.ofNullable(account.getIpayCustomerId())
                   .filter(id -> id.contains(pin))
                   .isPresent();
}
```

This version is more readable, and easier to test.

## adsadas

```java
private void orderStandardCard(
	AccountModel accountModel,
	CardRequestModel cardRequestModel,
	AddressModel residentialAddress,
	Long cardPaymentId,
	String cardHolderName,
	AuditTrailClientModel auditTrailClientModel
) {
//            String customerId = accountModel.getIpayCustomerId();
        try {
            String customerId = createRandomCustomerId();
//            if (StringUtils.isEmpty(customerId)) {
            // TODO: add new customer to ipay
//             customerId = addIpayCustomer(accountModel, residentialAddress);
//
//             // update ipayCustomerId to account table
//              accountService.updateIPayCustomerId(customerId, accountModel.getAccountNo());
//            }

            // Save info to db
            String newCardId = createCardApplicationAndCard(accountModel, cardRequestModel, null, cardPaymentId, cardHolderName);

            // TODO: send success notification

            auditTrailClientModel.getAuditContext().put("accountNo", accountModel.getAccountNo());
            auditTrailClientModel.getAuditContext().put("cardAttributes", CardConstant.SINGLE_CARD_PREFIX);
            auditTrailClientModel.getAuditContext().put("cardType", VIRTUAL.toLowerCase());
            auditTrailClientModel.getAuditContext().put("cardId", newCardId);
            auditTrailClientModel.getAuditContext().put("remainingContent", SharedConstant.PERIOD);
        } catch (Exception e) {
            auditTrailClientModel.setAction("User with accountNo: " + accountModel.getAccountNo() + " failed to order a virtual card.");
            throw e;
        }
    }

private void orderPremiumCard(
	AccountModel accountModel, CardRequestModel cardRequestModel, 
	AddressModel residentialAddress,
	Long cardPaymentId,
	String cardHolderName,
	int numberOfCards,
	List<String> newCardIdList,
	List<String> requestedCardTypeList,
	AuditTrailClientModel auditTrailClientModel
) {
        String newCardId = null;
        AddressModel mailingAddress = null;
        String ekycStatus = null;
        try {
            if (PHYSICAL.equalsIgnoreCase(cardRequestModel.getCardType())) {
                // TODO: Use account model to get user's mail address
                mailingAddress = generateRandomAddress();
                addressModelValidator.validate(mailingAddress);
            }

            // TODO: Use eKYC service to get user's eKYC status
            // Temporary usage, the status name not yet confirmed
            ekycStatus = "pending";

            // TODO: If user passed eKYC, can go through the normal flow
            switch (ekycStatus) {
                case "success" ->
                        newCardId = createCardApplicationAndCard(accountModel, cardRequestModel, mailingAddress, cardPaymentId, cardHolderName);
                case "pending" ->
                        createPendingCardApplication(accountModel, cardPaymentId, cardRequestModel, cardHolderName);
                default -> throw new CardException(CardErrorEnum.UNKNOWN_EKYC_STATUS);
            }

            if (newCardId != null) {
                newCardIdList.add(newCardId);
            }
            requestedCardTypeList.add(cardRequestModel.getCardType().toLowerCase());

            //TODO: send success notification

        } catch (Exception e) {
            //TODO: send fail notification
            throw e;
        } finally {
	        AuditContext auditContent = auditTrailClientModel.getAuditContext();

            String joinedCardIds = newCardIdList.isEmpty() ? SharedConstant.DASH : String.join(SharedConstant.COMMA, newCardIdList);


			String cardType;
			String cardAttributes;
			
            if (numberOfCards > 1) {
                String joinedCardTypes = String.join(CardConstant.AND, requestedCardTypeList);
                auditTrailClientModel.getAuditContext().put("cardAttributes", CardConstant.MULTIPLE_CARD_PREFIX);
                auditTrailClientModel.getAuditContext().put("cardType", joinedCardTypes);
            } else {
                auditTrailClientModel.getAuditContext().put("cardAttributes", CardConstant.SINGLE_CARD_PREFIX);
                auditTrailClientModel.getAuditContext().put("cardType", cardRequestModel.getCardType().toLowerCase());
            }
            
			AuditContextHolder auditContextHolder = 
		        AuditContextHolder.builder()
			        .accountNo(accountModel.getAccountNo())
			        .cardId(joinedCardIds)
			        .remainingContent(getRemainingContent(ekycStatus))
			        .cardType(cardType)
			        .cardAttributes(cardAttributes);
			        
			        
			setAuditContext(auditContext, auditContextHolder);
        }
    }


private String getRemainingContent
```

As we can see, the main issues are as follow:
1. Duplicated `finally` logic, which can be simplified.
2. Long parameters name, which is error prone.

To resolve these issues, we can introduce a new local record (Data Transfer Object) to encapsulate the long parameters, as follow:

```java
private static final String STANDARD = "standard";
private static final String PREMIUM = "premium";

@Builder
record OrderCardModel(
	String type;
	AccountModel accountModel,
	CardRequestModel cardRequestModel, 
	AddressModel residentialAddress,
	Long cardPaymentId,
	String cardHolderName,
	int numberOfCards,
	List<String> newCardIdList,
	List<String> requestedCardTypeList,
	AuditTrailClientModel auditTrailClientModel
)
```

Also, since the auditing is crucial, we can centralize the logic by putting everything in the `finally` block. To enhance the type safety, we can introduce another local storage object:

```java
@Builder
private class AuditContextHolder {
	private String accountNo;
	private String cardAttributes;
	private String cardType;
	private String cardId;
	private String remainingContent;

	public Map<String, Object> getEntrySet() {
		return Map.of(
			"accountNo", accountNo,
			"cardAttributes", cardAttributes,
			"cardType", cardType,
			"cardId", cardId,
			"remainingContent", remainingContent,
		)
	}
}
private void setAuditContext(AuditContext auditContext, AuditContextHolder holder) {
	for(Map.Entry<String, Object> entry : holder.getEntrySet()) {
		auditContext.put(entry.getKey(), entry.getValue());
	}
}
```