package com.ifast.ipaymy.modular.audittrail.service.aop;

import com.ifast.ipaymy.backend.util.SharedConstant;

import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface AuditTrail {

    enum Type {
        EMPTY,
        AUDIT_TRAIL_CLIENT,
        AUDIT_TRAIL_ADMIN,
    }

    Type type() default Type.EMPTY;

    AuditTrailModule.AdminModule adminModule() default AuditTrailModule.AdminModule.EMPTY;

    AuditTrailAction.AdminAction adminAction() default AuditTrailAction.AdminAction.EMPTY;

    AuditTrailModule.ClientModule clientModule() default AuditTrailModule.ClientModule.EMPTY;

    AuditTrailAction.ClientAction clientAction() default AuditTrailAction.ClientAction.EMPTY;

    /*
     SpEL expression. If skipIf condition is true, we will not save audit trail to db
     Note: We store the condition values in Map <String, Object>, hence it's not limited to string as value only.
     Sample Use Case 1:#{'sample.getId' == null}
     Sample use Case 2: #{sampleFlag == true && sample.getId == '123'}
     */
    String skipIf() default SharedConstant.EMPTY_STRING;

}




@Configuration
@ComponentScan
public class AuditTrailAopConfig {
}

package com.ifast.ipaymy.modular.audittrail.service.aop;

import com.ifast.ipaymy.modular.audittrail.domain.entity.AuditTrailAdminPk;
import com.ifast.ipaymy.modular.audittrail.domain.entity.AuditTrailClientPk;
import com.ifast.ipaymy.modular.audittrail.model.AuditTrailAdminModel;
import com.ifast.ipaymy.modular.audittrail.model.AuditTrailBaseModel;
import com.ifast.ipaymy.modular.audittrail.model.AuditTrailClientModel;
import com.ifast.ipaymy.modular.audittrail.service.constant.AuditTrailConstant;
import com.ifast.ipaymy.modular.audittrail.service.exception.AuditTrailErrorEnum;
import com.ifast.ipaymy.modular.audittrail.service.exception.AuditTrailException;
import com.ifast.ipaymy.modular.audittrail.service.mapper.AuditTrailAdminMapper;
import com.ifast.ipaymy.modular.audittrail.service.mapper.AuditTrailClientMapper;
import com.ifast.ipaymy.modular.audittrail.service.service.AuditTrailAdminService;
import com.ifast.ipaymy.modular.audittrail.service.service.AuditTrailClientService;
import com.ifast.ipaymy.modular.config.ThreadPoolConfig;
import com.ifast.ipaymy.backend.util.SharedConstant;
import com.ifast.ipaymy.backend.util.validator.ValidatorUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RequiredArgsConstructor
@Slf4j
@Component
@Aspect
public class AuditTrailAspect {

    //mapper
    private final AuditTrailClientMapper auditTrailClientMapper;
    private final AuditTrailAdminMapper auditTrailAdminMapper;

    //service
    private final AuditTrailClientService auditTrailClientService;
    private final AuditTrailAdminService auditTrailAdminService;

    private final SpelExpressionParser expressionParser = new SpelExpressionParser();

    /*
        For current stage, we will create new thread for every annotation in the list
        Todo: Potentially may need to refine thread resource
     */
    @Async(ThreadPoolConfig.AUDIT_TRAIL_THREAD)
    @AfterReturning(value = "@annotation(auditTrails)", returning = "ret")
    public void auditTrailsAdvice(JoinPoint joinPoint, AuditTrails auditTrails, Object ret) {
        for (AuditTrail trail : auditTrails.value()) {
            auditTrailAdvice(joinPoint, trail, ret);
        }
    }

    @Async(ThreadPoolConfig.AUDIT_TRAIL_THREAD)
    @AfterThrowing(value = "@annotation(auditTrails)", throwing = "e")
    public void auditTrailsThrowAdvice(JoinPoint joinPoint, AuditTrails auditTrails, Throwable e) {
        for (AuditTrail trail : auditTrails.value()) {
            auditTrailThrowAdvice(joinPoint, trail, e);
        }
    }

    @Async(ThreadPoolConfig.AUDIT_TRAIL_THREAD)
    @AfterReturning(value = "@annotation(auditTrail)", returning = "ret")
    public void auditTrailAdvice(JoinPoint joinPoint, AuditTrail auditTrail, Object ret) {
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method method = methodSignature.getMethod();

        log.info("Audit Trail from: " + method.getName());

        logAuditTrail(auditTrail, joinPoint, false);
    }

    @Async(ThreadPoolConfig.AUDIT_TRAIL_THREAD)
    @AfterThrowing(value = "@annotation(auditTrail)", throwing = "e")
    public void auditTrailThrowAdvice(JoinPoint joinPoint, AuditTrail auditTrail, Throwable e) {
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method method = methodSignature.getMethod();

        log.error(method.getName(), e);
        logAuditTrail(auditTrail, joinPoint, true);

    }

    private void logAuditTrail(AuditTrail auditTrail, JoinPoint joinPoint, boolean isException) {
        AuditTrailAdminModel auditTrailAdminModel = null;
        AuditTrailClientModel auditTrailClientModel = null;
        AuditTrail.Type type = auditTrail.type();

        //Clone object as AuditTrail List shares the same model
        //If no clone, the first insertion of audit trail will overwrite subsequent audit trails
        for (Object argument : joinPoint.getArgs()) {
            if (argument instanceof AuditTrailAdminModel) {
                auditTrailAdminModel = ((AuditTrailAdminModel) argument).clone();
                break;
            } else if (argument instanceof AuditTrailClientModel) {
                auditTrailClientModel = ((AuditTrailClientModel) argument).clone();
                break;
            }
        }

        //If both are null means the model is not found
        if (ValidatorUtils.isEmpty(auditTrailAdminModel) && ValidatorUtils.isEmpty(auditTrailClientModel)) {
            throw new AuditTrailException(AuditTrailErrorEnum.AUDIT_MODEL_NOT_FOUND);
        }

        Map<String, Object> auditContext = new HashMap<>();

        Optional.ofNullable(auditTrailAdminModel)
                .map(AuditTrailAdminModel::getAuditContext)
                .ifPresent(auditContext::putAll);

        Optional.ofNullable(auditTrailClientModel)
                .map(AuditTrailClientModel::getAuditContext)
                .ifPresent(auditContext::putAll);

        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariables(auditContext);
        /*
         * Skip condition:
         * 1. SkipIf condition is not null
         * 2. SkipIf condition met
         */
        boolean requireAudit = Optional.ofNullable(auditTrail.skipIf())
                .filter(ValidatorUtils::isNotBlank)
                .map(skipIf -> expressionParser.parseRaw(skipIf)
                        .getValue(context, Boolean.class))
                .orElse(true) && Optional.ofNullable(auditTrailAdminModel)
                .map(AuditTrailAdminModel::isRequiredAudit)
                .orElse(true) && Optional.ofNullable(auditTrailClientModel)
                .map(AuditTrailClientModel::isRequiredAudit)
                .orElse(true);

        if (requireAudit) {
            if (ValidatorUtils.isNotEmpty(auditTrailAdminModel)) {
                auditTrailAdminModel.setModule(getModule(auditTrailAdminModel.getModule(), auditTrail));
                auditTrailAdminModel.setAction(getAction(auditTrailAdminModel.getAction(), auditContext , auditTrail, isException));
                insertAuditTrail(type, auditTrailAdminModel);
            } else if (ValidatorUtils.isNotEmpty(auditTrailClientModel)) {
                auditTrailClientModel.setModule(getModule(auditTrailClientModel.getModule(), auditTrail));
                auditTrailClientModel.setAction(getAction(auditTrailClientModel.getAction(), auditContext, auditTrail, isException));
                insertAuditTrail(type, auditTrailClientModel);
            }
        }

        else {
            log.info("Skip audit trail condition met, skipping audit trail");
        }

        log.info("audit trail ended");
    }

    //Insert audit trail to database
    private void insertAuditTrail(AuditTrail.Type type, AuditTrailBaseModel auditTrailBaseModel) {
        switch (type) {
            case AUDIT_TRAIL_CLIENT -> {
                AuditTrailClientPk auditTrailClientPk = auditTrailClientMapper.mapToAuditTrailClientPk((AuditTrailClientModel) auditTrailBaseModel);
                auditTrailClientService.create(auditTrailClientPk);

            }
            case AUDIT_TRAIL_ADMIN -> {
                AuditTrailAdminPk auditTrailAdminPk = auditTrailAdminMapper.mapToAuditTrailAdminPk((AuditTrailAdminModel) auditTrailBaseModel);
                auditTrailAdminService.create(auditTrailAdminPk);
            }
        }
    }
    private String getModule(String module, AuditTrail auditTrail) {
        // Return original value if user already set a module value
        if (ValidatorUtils.isNotEmpty(module)) {
            return module;
        }

        // Check the audit trail type and return the corresponding module value
        module = switch (auditTrail.type()) {
            case EMPTY -> throw new AuditTrailException(AuditTrailErrorEnum.AUDIT_TYPE_NOT_FOUND);
            case AUDIT_TRAIL_CLIENT -> auditTrail.clientModule().toValue();
            case AUDIT_TRAIL_ADMIN -> auditTrail.adminModule().toValue();
        };

        // If module is still null or empty after the switch, throw an error
        if (ValidatorUtils.isEmpty(module)) {
            throw new AuditTrailException(AuditTrailErrorEnum.AUDIT_MODULE_NOT_FOUND);
        }

        return module;
    }

    private String getAction(String action, Map<String, Object> auditContext, AuditTrail auditTrail, boolean isException) {
        // Return the original value if user already set an action value
        if (ValidatorUtils.isNotBlank(action)) {
            // If there is an exception, append "failed" to the action
            return isException ? action.concat(AuditTrailConstant.APPEND_FAILED) : action;
        }

        action = switch (auditTrail.type()) {
            case EMPTY -> throw new AuditTrailException(AuditTrailErrorEnum.AUDIT_TYPE_NOT_FOUND);
            case AUDIT_TRAIL_CLIENT -> processAuditAction(auditTrail.clientAction().toValue(), auditContext);
            case AUDIT_TRAIL_ADMIN -> processAuditAction(auditTrail.adminAction().toValue(), auditContext);
        };

        return isException ? action.concat(AuditTrailConstant.APPEND_FAILED) : action;
    }


    //Replace string values with auditContext set
    //E.g. {userId} is replaced by auditContext.get(userId)
    private String processAuditAction(String action, Map<String, Object> auditContext) {
        if (ValidatorUtils.isBlank(action)) {
            throw new AuditTrailException(AuditTrailErrorEnum.AUDIT_ACTION_NOT_FOUND);
        }

        //If is empty means there are no values to be replaced in action
        if (ValidatorUtils.isEmpty(auditContext)) {
            return action;
        }

        // Define a Set to store the unique placeholders
        Set<String> placeHolderSet = new HashSet<>();
        Pattern pattern = Pattern.compile("\\{(.*?)\\}");
        Matcher matcher = pattern.matcher(action);

        // Find and add each placeholder to the set
        while (matcher.find()) {
            placeHolderSet.add(matcher.group(1));
        }

        for (String placeholder : placeHolderSet){
            Object replacement = auditContext.get(placeholder);
            //If action contains value to be replaced but key-value pair is not set, throw exception
            if (ValidatorUtils.isEmpty(replacement)){
                throw new AuditTrailException(AuditTrailErrorEnum.AUDIT_ACTION_PLACEHOLDER_NOT_FOUND);
            }
            action = action.replace(SharedConstant.OPEN_CURLY_BRACKET + placeholder + SharedConstant.CLOSE_CURLY_BRACKET, String.valueOf(replacement));
        }
        return action;
    }
}


package com.ifast.ipaymy.modular.audittrail.service.aop;

import org.springframework.context.annotation.Import;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Retention(value = RUNTIME)
@Target(value = {TYPE})
@Documented
@Import({
        AuditTrailAopConfig.class
})
public @interface EnableAuditTrailAop {
}
