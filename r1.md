package com.ifast.ipaymy.modular.card.service.service.cardapplication;

import com.ifast.ipaymy.modular.audittrail.model.AuditTrailClientModel;
import com.ifast.ipaymy.modular.audittrail.service.aop.AuditTrail;
import com.ifast.ipaymy.modular.audittrail.service.aop.AuditTrailAction;
import com.ifast.ipaymy.modular.audittrail.service.aop.AuditTrailModule;
import com.ifast.ipaymy.modular.card.domain.entity.*;
import com.ifast.ipaymy.modular.card.domain.query.CardApplicationQuery;
import com.ifast.ipaymy.modular.card.domain.repository.*;
import com.ifast.ipaymy.modular.card.service.config.SecretKeyConfig;
import com.ifast.ipaymy.modular.card.service.constant.CardConstant;
import com.ifast.ipaymy.modular.card.service.exception.CardException;
import com.ifast.ipaymy.modular.card.service.exception.CardErrorEnum;

import com.ifast.ipaymy.modular.card.service.mapper.CardMapper;
import com.ifast.ipaymy.modular.card.service.service.general.CardGeneralService;
import com.ifast.ipaymy.modular.card.service.validator.*;
import com.ifast.ipaymy.modular.model.card.*;
import com.ifast.ipaymy.modular.productsetup.domain.entity.card.ProductCardBean;
import com.ifast.ipaymy.modular.productsetup.service.service.card.ProductCardService;
import com.ifast.ipaymy.backend.util.SharedConstant;
import com.ifast.ipaymy.backend.util.enums.BaseEnumMapper;
import com.ifast.ipaymy.backend.util.enums.card.CardApplicationStatusEnum;
import com.ifast.ipaymy.backend.util.enums.card.CardShippingStatusEnum;
import com.ifast.ipaymy.backend.util.enums.card.CardShippingTypeEnum;
import com.ifast.ipaymy.backend.util.enums.card.CardStatusEnum;
import com.ifast.ipaymy.backend.util.enums.card.ConvertedCardStatusEnum;
import com.ifast.ipaymy.backend.util.serialnumber.sequence.SequenceConstant;
import com.ifast.ipaymy.backend.util.serialnumber.sequence.SequenceService;
//import com.ifast.ipaymy.backend.util.system.AESUtil;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

import static com.ifast.ipaymy.modular.card.service.constant.CardConstant.*;
import static com.ifast.ipaymy.backend.util.SharedConstant.DEFAULT_OFFSET_ZONE;

@Slf4j
@RequiredArgsConstructor
@Service
public class CardApplicationServiceImpl implements CardApplicationService {
    // Services
    private final ProductCardService productCardService;
    private final SequenceService sequenceService;
    private final CardMapper cardMapper;
    private final SecretKeyConfig secretKeyConfig;
    private final CardGeneralService cardGeneralService;
    private final BaseEnumMapper baseEnumMapper;

    // DAO
    private final CardDao cardDao;
    private final CardApplicationDao cardApplicationDao;
    private final CardShippingHistoryDao cardShippingHistoryDao;
    private final CardShippingDao cardShippingDao;

    // Queries
    private final CardApplicationQuery cardApplicationQuery;

    // Validators
    private final CardOrderRequestModelValidator cardOrderRequestModelValidator;
    private final ActivatePhysicalCardRequestModelValidator activatePhysicalCardRequestModelValidator;
    private final GetShippingDetailsRequestModelValidator getShippingDetailsRequestModelValidator;
    private final GetCardApplicationAndTrackingRequestModelValidator getCardApplicationAndTrackingRequestModelValidator;
    private final ValidateCardPinRequestModelValidator validateCardPinRequestModelValidator;
    private final AddressModelValidator addressModelValidator;
    private final ConfirmCardRequestModelValidator confirmCardRequestModelValidator;
    private final GetExistingCardApplicationRequestModelValidator getExistingCardApplicationRequestModelValidator;

    // To add physical and digital card
    @Override
    @Transactional
    @AuditTrail(type = AuditTrail.Type.AUDIT_TRAIL_CLIENT, clientModule = AuditTrailModule.ClientModule.CARD, clientAction = AuditTrailAction.ClientAction.CARD_ORDER)
    public void addCard(CardOrderRequestModel cardOrderRequestModel, AuditTrailClientModel auditTrailClientModel) {
        cardOrderRequestModelValidator.validate(cardOrderRequestModel);
        String accountNo = cardOrderRequestModel.getAccountNo();
        Long cardPaymentId = cardOrderRequestModel.getCardPaymentId();
        String cardHolderName = cardOrderRequestModel.getCardHolderName();
        int numberOfCards = 0;
        List<String> newCardIdList = new ArrayList<>();
        List<String> requestedCardTypeList = new ArrayList<>();

        for (CardRequestModel cardRequestModel : cardOrderRequestModel.getRequestCards()) {
            numberOfCards += 1;
            // TODO: get account model, temporarily use data generator
            AccountModel accountModel = generateRandomAccountModel(accountNo);

            // TODO: use account model to get user's residential address, temporarily use data generator
            AddressModel residentialAddress = generateRandomAddress();

            addressModelValidator.validate(residentialAddress);

            ProductCardBean productCardBean = productCardService.getProductCard(cardRequestModel.getCardCategory(),
                    cardRequestModel.getCardType(), cardRequestModel.getPaymentNetwork(), cardRequestModel.getProductCardId());

            // TODO: Use account service to get product account id
            if (!accountModel.getProductAccountId().equals(productCardBean.getProductAccountId())) {
                throw new CardException(CardErrorEnum.INVALID_PRODUCT_FOR_PRODUCT_ACCOUNT);
            }

            // TODO: Use product account service to get product account name
            // temporary usage
            String productAccountName = "premium";

            switch (productAccountName) {
                // temporary use text here, will change to account constant value
                case "standard" -> orderStandardCard(
                        accountModel, cardRequestModel, residentialAddress, cardPaymentId, cardHolderName, auditTrailClientModel
                );
                // temporary use text here, will change to account constant value
                case "premium" -> orderPremiumCard(
                        accountModel, cardRequestModel, residentialAddress, cardPaymentId, cardHolderName, numberOfCards, newCardIdList, requestedCardTypeList, auditTrailClientModel
                );
                default -> throw new CardException(CardErrorEnum.UNKNOWN_PRODUCT_ACCOUNT_TYPE);
            }
        }
    }

    // To activate physical card
    @Override
    @Transactional
    @AuditTrail(type = AuditTrail.Type.AUDIT_TRAIL_CLIENT, clientModule = AuditTrailModule.ClientModule.CARD, clientAction = AuditTrailAction.ClientAction.CARD_ACTIVATE_PHYSICAL)
    public void activatePhysicalCard(ActivatePhysicalCardRequestModel activatePhysicalCardRequestModel, AuditTrailClientModel auditTrailClientModel) {
        try {
            activatePhysicalCardRequestModelValidator.validate(activatePhysicalCardRequestModel);
            String accountNo = activatePhysicalCardRequestModel.getAccountNo();
            String cardId = activatePhysicalCardRequestModel.getCardId();
            ViewAccountCardDetailsBean cardBean = cardGeneralService.getViewClientCardDetailsBean(cardId);
            IPayActivateCardRequestModel iPayActivateCardRequestModel = new IPayActivateCardRequestModel();
            iPayActivateCardRequestModel.setRemark(CardConstant.REMARK_ACTIVATE_CARD);

            // TODO: Set Card Pin on IPAY

            // TODO: activateIpayCard through Ipay service
            // activateIpayCard(viewClientCardDetailsBean, iPayActivateCardRequestModel);

            // update card status to activated
            CardBean card = cardGeneralService.getCardBean(cardId);
            card.setStatus(CardStatusEnum.ACTIVATED);
            card.setActivationDate(OffsetDateTime.now(DEFAULT_OFFSET_ZONE));
            cardDao.save(card);
            cardDao.flush();

            // update application status to shipped once activated
            CardApplicationUpdateModel cardApplicationUpdateModel = new CardApplicationUpdateModel();
            cardApplicationUpdateModel.setProductCardId(cardBean.getProductCardId());
            cardApplicationUpdateModel.setCardShippingStatus(CardShippingStatusEnum.SHIPPED.toValue());
            cardApplicationUpdateModel.setCardStatus(ConvertedCardStatusEnum.ACTIVATED.toValue());
            updateCardApplication(accountNo, cardApplicationUpdateModel, false);

            // TODO: Send success notification

        } catch (Exception e) {
            // TODO: Send failed notification
            throw e;
        } finally {
            auditTrailClientModel.getAuditContext()
                    .put("accountNo", activatePhysicalCardRequestModel.getAccountNo());
            auditTrailClientModel.getAuditContext()
                    .put("cardId", activatePhysicalCardRequestModel.getCardId());
        }
    }

    // To get card application and shipping history record
    @Override
    @Transactional(readOnly = true)
    public CardApplicationAndTrackingResponseModel getCardApplicationAndTracking(GetCardApplicationAndTrackingRequestModel getCardApplicationAndTrackingRequestModel) {
        getCardApplicationAndTrackingRequestModelValidator.validate(getCardApplicationAndTrackingRequestModel);
        String accountNo = getCardApplicationAndTrackingRequestModel.getAccountNo();
        CardApplicationAndTrackingResponseModel cardApplicationAndTrackingResponseModel = new CardApplicationAndTrackingResponseModel();
        cardApplicationAndTrackingResponseModel.setCardApplicationModel(getCardApplicationDetails(accountNo));
        List<CardShippingHistoryModel> cardShippingHistoryModelList = cardApplicationQuery.getCardShippingHistoryModelListByAccountNo(accountNo);
        cardApplicationAndTrackingResponseModel.setCardShippingHistoryModelList(cardShippingHistoryModelList);
        return cardApplicationAndTrackingResponseModel;
    }

    // To get shipping detail (status, estimated time for start and end, isFirstTimeOrder)
    @Override
    public ShippingDetailsResponseModel getShippingDetails(GetShippingDetailsRequestModel getShippingDetailsRequestModel) {
        getShippingDetailsRequestModelValidator.validate(getShippingDetailsRequestModel);
        String accountNo = getShippingDetailsRequestModel.getAccountNo();
        Long productCardId = getShippingDetailsRequestModel.getProductCardId();
        ShippingDetailsResponseModel shippingDetailsResponseModel = new ShippingDetailsResponseModel();
        ViewAccountCardDetailsBean viewAccountCardDetailsBean = cardGeneralService.findCardInUse(accountNo, productCardId);

        if (ObjectUtils.isNotEmpty(viewAccountCardDetailsBean)) {
            CardShippingBean cardShippingBean = cardGeneralService.getCardShippingBean(viewAccountCardDetailsBean.getCardApplicationId());

            shippingDetailsResponseModel.setShippingStatus(viewAccountCardDetailsBean.getShippingStatus().toValue());
            // only return date if status = shipping
            if (ObjectUtils.isNotEmpty(cardShippingBean) && CardShippingStatusEnum.SHIPPING.equals(cardShippingBean.getStatus())) {
                shippingDetailsResponseModel.setEstimatedArrivalStartDate(cardShippingBean.getEstimatedArrivalStartDate());
                shippingDetailsResponseModel.setEstimatedArrivalEndDate(cardShippingBean.getEstimatedArrivalEndDate());
            }
        }

        // check if have existing terminated physical card
        ViewAccountCardDetailsBean terminatedViewCardDetailsBean = cardGeneralService.findLatestTerminatedCard(accountNo, productCardId);

        if (terminatedViewCardDetailsBean == null) {
            shippingDetailsResponseModel.setIsFirstTimeOrder(true);
        } else {
            shippingDetailsResponseModel.setIsFirstTimeOrder(false);

            // check if the card in use is empty, if empty check if the terminated reason is returned/gone
            if (viewAccountCardDetailsBean == null && CardShippingStatusEnum.RETURNED_GONE.equals(terminatedViewCardDetailsBean.getShippingStatus())) {
                shippingDetailsResponseModel.setShippingStatus(terminatedViewCardDetailsBean.getShippingStatus().toValue());
            }
        }

        return shippingDetailsResponseModel;
    }

    // To validate card pin format before activation
    @Override
    @Transactional(readOnly = true)
    public boolean validateCardPin(ValidateCardPinRequestModel validateCardPinRequestModel) {
        validateCardPinRequestModelValidator.validate(validateCardPinRequestModel);

        String pin = validateCardPinRequestModel.getPin();
        String accountNo = validateCardPinRequestModel.getAccountNo();
        String decryptedPin = getDecryptedJsonString(pin);

        if (decryptedPin == null || decryptedPin.length() != CardConstant.PIN_LENGTH || !decryptedPin.matches("\\d{6}")) {
            return false;
        }

        AccountModel accountModel = generateRandomAccountModel(accountNo);

        // If any condition is true (invalid), return false
        if (decryptedPin.chars().distinct().count() == 1 ||                              // all same digits
                accountNo.contains(decryptedPin) ||                                      // pin part of accountNo
                (StringUtils.isNotBlank(accountModel.getIpayCustomerId()) &&
                        accountModel.getIpayCustomerId().contains(decryptedPin)) ||      // pin part of iPay ID
                isSequential(decryptedPin) ||                                            // ascending or descending
                matchesDobPattern(decryptedPin, accountModel)) {
            return false;
        }

        // If all checks pass, return true
        return true;
    }

    @Override
    public List<CardApplicationInfoModel> findCardApplicationList(GetExistingCardApplicationRequestModel getExistingCardApplicationRequestModel) {
        getExistingCardApplicationRequestModelValidator.validate(getExistingCardApplicationRequestModel);

        return cardApplicationDao
                .findCardApplicationBeanByAccountNo(getExistingCardApplicationRequestModel.getAccountNo())
                .filter(list -> !list.isEmpty())
                .orElse(Collections.emptyList())
                .stream()
                .map(cardMapper::mapCardApplicationBeanToModel)
                .toList();
    }


    private void updateCardApplication(String accountNo, CardApplicationUpdateModel cardApplicationUpdateModel, boolean isSystem) {
        CardApplicationBean cardApplicationBean = cardGeneralService.getCardApplicationBean(accountNo, cardApplicationUpdateModel.getProductCardId(), CardApplicationStatusEnum.COMPLETED);
        CardShippingBean cardShippingBean = cardGeneralService.getCardShippingBean(cardApplicationBean.getId());
        CardBean cardBean = cardGeneralService.getCardBean(cardApplicationBean.getId());
        ViewAccountCardDetailsBean viewAccountCardDetailsBean = cardGeneralService.getViewClientCardDetailsBean(cardBean.getId());

        String newShippingStatus = cardApplicationUpdateModel.getCardShippingStatus();

        if (StringUtils.equals(newShippingStatus, cardShippingBean.getStatus().toValue())) {
            return;
        }

        CardShippingStatusEnum shippingStatus = baseEnumMapper.toEnum(newShippingStatus, CardShippingStatusEnum.class);

        // Use for update card shipping status API
        String cardStatus;
        if (ObjectUtils.isNotEmpty(cardApplicationUpdateModel.getCardStatus())) {
            cardStatus = cardApplicationUpdateModel.getCardStatus();
        } else {
            cardStatus = viewAccountCardDetailsBean.getConvertedCardStatus().toValue();
        }
        CardStatusEnum currentCardStatus = baseEnumMapper.toEnum(cardStatus, CardStatusEnum.class);

        cardShippingBean.setStatus(shippingStatus);
        cardShippingBean.setUpdatedBy(isSystem ? SharedConstant.SYSTEM : accountNo);
        cardShippingDao.save(cardShippingBean);
        cardShippingDao.flush();

        OffsetDateTime shippingStatusDate = cardShippingBean.getUpdatedDate() != null
                ? cardShippingBean.getUpdatedDate()
                : cardShippingBean.getCreatedDate();

        CardShippingHistoryBean cardShippingHistoryBean = cardMapper.toCardShippingHistoryBean(cardApplicationBean.getId(), cardShippingBean, accountNo, shippingStatusDate);
        cardShippingHistoryBean.setCardStatus(currentCardStatus);
        cardShippingHistoryDao.save(cardShippingHistoryBean);

        if (Objects.equals(CardShippingStatusEnum.RETURNED_GONE, shippingStatus)) {
            // TODO: terminate card
            // TODO: send notification to inform card terminated

        } else if (Objects.equals(CardShippingStatusEnum.SHIPPING, shippingStatus)) {
            // TODO: send notification to inform estimated time
        }
    }

    private CardShippingTypeEnum getShippingType(String countryCode) {
        if (CardConstant.ACCEPTED_COUNTRY_CODES.contains(countryCode)) {
            return CardShippingTypeEnum.DOMESTIC;
        } else {
            throw new CardException(CardErrorEnum.INVALID_DELIVERY_ADDRESS);
        }
    }

    private void orderStandardCard(AccountModel accountModel, CardRequestModel cardRequestModel, AddressModel residentialAddress, Long cardPaymentId, String cardHolderName, AuditTrailClientModel auditTrailClientModel) {
//            String customerId = accountModel.getIpayCustomerId();
        try {
            String customerId = createRandomCustomerId();
//            if (StringUtils.isEmpty(customerId)) {
            // TODO: add new customer to ipay
//             customerId = addIpayCustomer(accountModel, residentialAddress);
//
//             // update ipayCustomerId to account table
//              accountService.updateIPayCustomerId(customerId, accountModel.getAccountNo());
//            }

            // Save info to db
            String newCardId = createCardApplicationAndCard(accountModel, cardRequestModel, null, cardPaymentId, cardHolderName);

            // TODO: send success notification

            auditTrailClientModel.getAuditContext().put("accountNo", accountModel.getAccountNo());
            auditTrailClientModel.getAuditContext().put("cardAttributes", CardConstant.SINGLE_CARD_PREFIX);
            auditTrailClientModel.getAuditContext().put("cardType", VIRTUAL.toLowerCase());
            auditTrailClientModel.getAuditContext().put("cardId", newCardId);
            auditTrailClientModel.getAuditContext().put("remainingContent", SharedConstant.PERIOD);
        } catch (Exception e) {
            auditTrailClientModel.setAction("User with accountNo: " + accountModel.getAccountNo() + " failed to order a virtual card.");
            throw e;
        }
    }

    private void orderPremiumCard(AccountModel accountModel, CardRequestModel cardRequestModel, AddressModel residentialAddress, Long cardPaymentId, String cardHolderName, int numberOfCards, List<String> newCardIdList, List<String> requestedCardTypeList, AuditTrailClientModel auditTrailClientModel) {
        String newCardId = null;
        AddressModel mailingAddress = null;
        String ekycStatus = null;
        try {
            // TODO: add new customer to ipay
//        String customerId = accountModel.getIpayCustomerId();
//        if (StringUtils.isEmpty(customerId)) {
//            customerId = addIpayCustomer(accountModel, residentialAddress);
//
//            // update ipayReferenceNo to client table
//            accountService.updateClientIPayReferenceNo(customerId, clientModel.getAccountNo());
//        }

            if (PHYSICAL.equalsIgnoreCase(cardRequestModel.getCardType())) {
                // TODO: Use account model to get user's mail address
                mailingAddress = generateRandomAddress();
                addressModelValidator.validate(mailingAddress);
            }

            // TODO: Use eKYC service to get user's eKYC status
            // Temporary usage, the status name not yet confirmed
            ekycStatus = "pending";

            // TODO: If user passed eKYC, can go through the normal flow
            switch (ekycStatus) {
                case "success" ->
                        newCardId = createCardApplicationAndCard(accountModel, cardRequestModel, mailingAddress, cardPaymentId, cardHolderName);
                case "pending" ->
                        createPendingCardApplication(accountModel, cardPaymentId, cardRequestModel, cardHolderName);
                default -> throw new CardException(CardErrorEnum.UNKNOWN_EKYC_STATUS);
            }

            if (newCardId != null) {
                newCardIdList.add(newCardId);
            }
            requestedCardTypeList.add(cardRequestModel.getCardType().toLowerCase());

            //TODO: send success notification

        } catch (Exception e) {
            //TODO: send fail notification
            throw e;
        } finally {
            auditTrailClientModel.getAuditContext().put("accountNo", accountModel.getAccountNo());

            String joinedCardIds = newCardIdList.isEmpty() ? SharedConstant.DASH : String.join(SharedConstant.COMMA, newCardIdList);

            if (numberOfCards > 1) {
                String joinedCardTypes = String.join(CardConstant.AND, requestedCardTypeList);
                auditTrailClientModel.getAuditContext().put("cardAttributes", CardConstant.MULTIPLE_CARD_PREFIX);
                auditTrailClientModel.getAuditContext().put("cardType", joinedCardTypes);
            } else {
                auditTrailClientModel.getAuditContext().put("cardAttributes", CardConstant.SINGLE_CARD_PREFIX);
                auditTrailClientModel.getAuditContext().put("cardType", cardRequestModel.getCardType().toLowerCase());
            }

            auditTrailClientModel.getAuditContext().put("cardId", joinedCardIds);

            switch (ekycStatus) {
                case "success" ->
                        auditTrailClientModel.getAuditContext().put("remainingContent", SharedConstant.PERIOD);
                case "pending" ->
                        auditTrailClientModel.getAuditContext().put("remainingContent", CardConstant.CARD_ORDER_PENDING_EKYC_TEXTS);
                default -> throw new CardException(CardErrorEnum.UNKNOWN_EKYC_STATUS);
            }
        }
    }

    private String createCardApplicationAndCard(AccountModel accountModel, CardRequestModel cardRequestModel, AddressModel mailingAddress, Long cardPaymentId, String cardHolderName) {
        // TODO: Add Ipay card
        IPayCardModel iPayCardModel = createRandomIPayCardModel();

        CardApplicationBean cardApplicationBean = buildCardApplication(
                accountModel, cardRequestModel, iPayCardModel.getCardOrderId(),
                CardApplicationStatusEnum.COMPLETED.toValue(), cardPaymentId, cardHolderName
        );

        String newCardId = null;
        if (cardRequestModel.getCardType().equalsIgnoreCase(PHYSICAL)) {
            newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), accountModel.getAccountNo(), cardApplicationBean.getCardApplicantName(), CardStatusEnum.INACTIVE, PHYSICAL);
        } else {
            newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), accountModel.getAccountNo(), cardApplicationBean.getCardApplicantName(), CardStatusEnum.ACTIVATED, VIRTUAL);
        }

        if (ObjectUtils.isNotEmpty(mailingAddress)) {
            createShippingRecords(cardApplicationBean, mailingAddress, accountModel.getAccountNo());
        }
        return newCardId;
    }

    private CardApplicationBean buildCardApplication(AccountModel accountModel, CardRequestModel cardRequestModel, String cardOrderId, String status, Long cardPaymentId, String cardHolderName) {
        // Create the CardApplicationBean using the mapper
        CardApplicationBean cardApplicationBean = cardMapper.toCardApplicationBean(cardRequestModel, cardPaymentId, accountModel.getAccountNo(),
                cardOrderId, status, cardHolderName);

        // Save info to db
        return cardApplicationDao.save(cardApplicationBean);
    }

    private void createPendingCardApplication(AccountModel accountModel, Long cardPaymentId, CardRequestModel cardRequestModel, String cardHolderName) {
        CardApplicationBean cardApplicationBean = cardMapper.toCardApplicationBean(
                cardRequestModel,
                cardPaymentId,
                accountModel.getAccountNo(),
                null,
                CardApplicationStatusEnum.PENDING.toValue(),
                cardHolderName
        );
        cardApplicationDao.save(cardApplicationBean);
    }

    private void createShippingRecords(CardApplicationBean cardApplicationBean, AddressModel mailingAddress, String accountNo) {
        CardShippingRequestModel shippingRequest = new CardShippingRequestModel();
        shippingRequest.setDeliveryAddress(mailingAddress);

        CardShippingTypeEnum shippingType = getShippingType(mailingAddress.getCountryCode());
        OffsetDateTime estimatedArrivalStartDate = OffsetDateTime.now(DEFAULT_OFFSET_ZONE).plusDays(CardConstant.ESTIMATED_ARRIVAL_START_INCREMENT);
        OffsetDateTime estimatedArrivalEndDate = OffsetDateTime.now(DEFAULT_OFFSET_ZONE).plusDays(CardConstant.ESTIMATED_ARRIVAL_END_INCREMENT);
        CardShippingBean shippingBean = cardMapper.toCardShippingBean(
                cardApplicationBean.getId(), shippingRequest, accountNo,
                CardShippingStatusEnum.PENDING_TO_SHIP.toValue(),
                estimatedArrivalStartDate, estimatedArrivalEndDate
        );
        ProductCardLogisticBean logistic = cardGeneralService.getLogistic(shippingType);
        shippingBean.setLogistic(logistic);
        shippingBean.setProductCardLogisticId(logistic.getId());
        shippingBean.setCountryCode(SharedConstant.DEFAULT_COUNTRY_CODE);
        cardShippingDao.save(shippingBean);
        cardShippingDao.flush();

        OffsetDateTime shippingStatusDate = shippingBean.getUpdatedDate() != null
                ? shippingBean.getUpdatedDate()
                : shippingBean.getCreatedDate();

        CardShippingHistoryBean history = cardMapper.toCardShippingHistoryBean(
                cardApplicationBean.getId(), shippingBean, accountNo, shippingStatusDate
        );
        history.setCardStatus(CardStatusEnum.INACTIVE);
        cardShippingHistoryDao.save(history);
    }

    @Override
    @Transactional
    public void confirmCard(ConfirmCardRequestModel confirmCardRequestModel) {
        confirmCardRequestModelValidator.validate(confirmCardRequestModel);
        List<String> cardTypeList = new ArrayList<>();
        List<String> newCardIdList = new ArrayList<>();
        String accountNo = confirmCardRequestModel.getAccountNo();

        try {
            // TODO: Use account model to get user's mail address
//        AccountBean accountRecord = accountService.getAccountByAccountNo(accountNo);
//        AddressModel mailingAddress = new AddressModel();
//        mailingAddress.setAddressLine1(accountRecord.getMailAddress1);
//        mailingAddress.setAddressLine2(accountRecord.getMailAddress2);
//        mailingAddress.setCountryCode(accountRecord.getMailCountryCode);
//        mailingAddress.setState(accountRecord.getMailState);
//        mailingAddress.setPostalCode(accountRecord.getMailZip);
//        mailingAddress.setCity(accountRecord.getMailTown);
            AddressModel mailingAddress = generateRandomAddress();
            // temporarily address
            CardShippingRequestModel cardShippingRequestModel = new CardShippingRequestModel();
            cardShippingRequestModel.setDeliveryAddress(mailingAddress);

            // Validate mailing address
            addressModelValidator.validate(cardShippingRequestModel.getDeliveryAddress());

            for (Long cardApplicationId : confirmCardRequestModel.getCardApplicationIds()) {
                CardApplicationBean cardApplicationBean = cardGeneralService.getCardApplicationBean(cardApplicationId);
                cardApplicationBean.setStatus(CardApplicationStatusEnum.COMPLETED);

                ProductCardBean productCardBean = productCardService.getProductCard(cardApplicationBean.getProductCardId());

                // TODO: get ipay customer id through account service
                //String customerId = accountModel.getIpayCustomerId();

                // TODO: add card to ipay
                // IPayCardModel iPayCardModel = addIpayCard(accountModel, customerId);
                // fake data generator
                IPayCardModel iPayCardModel = createRandomIPayCardModel();
                cardApplicationBean.setCardOrderId(iPayCardModel.getCardOrderId());
                cardApplicationDao.save(cardApplicationBean);

                String newCardId;
                String cardType = productCardBean.getCardType();

                if (productCardBean.getCardType().equalsIgnoreCase(PHYSICAL)) {
                    newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), accountNo, cardApplicationBean.getCardApplicantName(), CardStatusEnum.INACTIVE, PHYSICAL);
                    createShippingRecords(cardApplicationBean, cardShippingRequestModel.getDeliveryAddress(), accountNo);
                } else {
                    newCardId = createCard(iPayCardModel, cardApplicationBean.getId(), cardApplicationBean.getAccountNo(), cardApplicationBean.getCardApplicantName(), CardStatusEnum.ACTIVATED, VIRTUAL);
                }

                if (newCardId != null) {
                    newCardIdList.add(newCardId);
                }
                cardTypeList.add(cardType);

                //TODO: send success notification
            }

            String joinedCardTypes = String.join(CardConstant.AND, cardTypeList);
            String joinedCardIds = newCardIdList.isEmpty() ? SharedConstant.DASH : String.join(SharedConstant.COMMA, newCardIdList);

            log.info("[CONFIRM_CARD] response: {} card(s) [{}] with ID: {} owned by user with Account No {} is created.",
                    cardTypeList.size(), joinedCardTypes, joinedCardIds, accountNo);


        } catch (Exception e) {
            //TODO: send fail notification
            throw e;
        }
    }

    //<--------Start: Data generator------------>
    private static AccountModel generateRandomAccountModel(String accountNo) {
        AccountModel accountModel = new AccountModel();

        // Generate random Account No
        accountModel.setAccountNo(accountNo);

        // Generate random NRIC Name
        accountModel.setNricName(generateRandomString());

        // Generate random First Name
        accountModel.setFirstName(generateRandomString());

        // Generate random Last Name
        accountModel.setLastName(generateRandomString());

        accountModel.setProductAccountId(2L);
        accountModel.setDateOfBirth(OffsetDateTime.parse("2022-12-05T16:00:00+08:00"));

        return accountModel;
    }

    private static AddressModel generateRandomAddress() {
        AddressModel addressModel = new AddressModel();

        // Random Address details
        addressModel.setAddressLine1(generateRandomString());
        addressModel.setAddressLine2(generateRandomString());
        addressModel.setState(generateRandomString());
        addressModel.setCity(generateRandomString());
        addressModel.setPostalCode(generateRandomPostalCode());
        addressModel.setCountryCode("MY");

        return addressModel;
    }

    private static String generateRandomPostalCode() {
        int postalCode = (int) (Math.random() * 90000) + 10000; // ensures 5 digits
        return String.valueOf(postalCode);
    }

    private static String generateRandomString() {
        int leftLimit = 97; // ASCII value for 'a'
        int rightLimit = 122; // ASCII value for 'z'
        int targetStringLength = 10; // Length of the random string
        Random random = new Random();

        return random.ints(leftLimit, rightLimit + 1)
                .limit(targetStringLength)
                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
                .toString();
    }

    private String createRandomCustomerId() {
        // Generate a unique customer ID in the format FAKECL followed by a random number
        String randomNumber = String.format("%07d", (int) (Math.random() * 10000000));
        return "FAKECL" + randomNumber;
    }

    private IPayCardModel createRandomIPayCardModel() {
        IPayCardModel iPayCardModel = new IPayCardModel();

        // Generate random card ID (using UUID)
        iPayCardModel.setCardId(generateIpayCardId());

        // Generate a random 16-digit card number
        String cardNumber = generateRandomCardNumber();
        iPayCardModel.setCardNumber(cardNumber);

        // Set random last 4 digits (last 4 digits of the card number)
        iPayCardModel.setPanLast4(cardNumber.substring(cardNumber.length() - 4));

        // Set random first 6 digits (the BIN part)
        iPayCardModel.setPanFirst6(cardNumber.substring(0, 6));
        iPayCardModel.setCardOrderId(generateRandom10DigitNumber());

        // Generate a random expiry date (e.g., random month and year in the future)
        String expiryDate = generateRandomExpiryDate();
        iPayCardModel.setCardExpiry(expiryDate);

        return iPayCardModel;
    }

    private String generateRandom10DigitNumber() {
        Random random = new Random();
        StringBuilder sb = new StringBuilder(10);
        for (int i = 0; i < 10; i++) {
            sb.append(random.nextInt(10));
        }
        return sb.toString();
    }

    private String generateIpayCardId() {
        String prefix = "CARD";
        String date = LocalDate.now()
                .format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        int randomNumber = (int) (Math.random() * 1_000_000);
        String formattedNumber = String.format("%06d", randomNumber);
        return prefix + date + formattedNumber;
    }

    private String generateRandomCardNumber() {
        Random random = new Random();
        StringBuilder cardNumber = new StringBuilder();

        for (int i = 0; i < 16; i++) {
            cardNumber.append(random.nextInt(10));
        }

        return cardNumber.toString();
    }

    private String generateRandomExpiryDate() {
        // Generate a random expiry date (Month/Year) within the next 5 years
        Random random = new Random();

        int currentYear = Year.now().getValue();
        int year = currentYear + random.nextInt(5);
        int month = 1 + random.nextInt(12);

        YearMonth yearMonth = YearMonth.of(year, month);
        return yearMonth.format(DateTimeFormatter.ofPattern("yyyyMM"));
    }
    //<--------End: Data generator------------>

    private String createCard(IPayCardModel iPayCardModel, Long cardApplicationId, String accountNo, String cardApplicantName, CardStatusEnum cardStatusEnum, String cardType) {
//      Use later when apply to IPAY
//        if (iPayCardModel == null) {
//            throw new GlobalExceptionHandling(GeneralErrorEnum.INTERNAL_SERVER_ERROR_CONTACT);
//        }

        CardBean cardBean = cardMapper.toCardBean(iPayCardModel, cardApplicationId, cardStatusEnum, accountNo, cardApplicantName);
        setRemainingCardBean(cardBean, iPayCardModel, cardType);
        cardDao.save(cardBean);

//  `   TODO: set default spending limit
//      addDefaultLimitConfiguration(accountNo, cardType);

        return cardBean.getId();
    }

    private void setRemainingCardBean(CardBean cardBean, IPayCardModel iPayCardModel, String cardType) {
        String cardId = sequenceService.generateSerialNumber(SequenceConstant.SequenceEnum.CARD_ID_SEQ);
        OffsetDateTime expiryDate = ipayExpiryDateToOffsetDateTime(iPayCardModel.getCardExpiry());
        if (StringUtils.equalsIgnoreCase(CardConstant.VIRTUAL, cardType)) {
            cardMapper.updateCardBeanWithRemainingFields(cardBean, cardId, expiryDate, false, false, false, OffsetDateTime.now(DEFAULT_OFFSET_ZONE));
        } else if (StringUtils.equalsIgnoreCase(CardConstant.PHYSICAL, cardType)) {
            cardMapper.updateCardBeanWithRemainingFields(cardBean, cardId, expiryDate, true, false, true, null);
        }
    }

    private OffsetDateTime ipayExpiryDateToOffsetDateTime(String dateString) {
        // TODO: Identiffy what timezone the ipay date return, cause when they send their date, it may be different timezone
        SimpleDateFormat formatter = new SimpleDateFormat(CardConstant.IPAY_DATE_FORMAT_YYYYMM);
        formatter.setTimeZone(TimeZone.getTimeZone(SharedConstant.DEFAULT_TIMEZONE));

        try {
            // Parse to Date
            Date parsedDate = formatter.parse(dateString);

            // Use Calendar in UTC to avoid time zone shift
            Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(SharedConstant.DEFAULT_TIMEZONE));
            cal.setTime(parsedDate);
            cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
            cal.set(Calendar.HOUR_OF_DAY, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MILLISECOND, 0);

            // Convert to OffsetDateTime in UTC
            return convertDateToOffsetDateTime(cal.getTime());
        } catch (ParseException e) {
            return null;
        }
    }

    private OffsetDateTime convertDateToOffsetDateTime(Date date) {
        return date.toInstant().atOffset(DEFAULT_OFFSET_ZONE);
    }

    private CardApplicationModel getCardApplicationDetails(String accountNo) {
        List<ViewAccountCardDetailsBean> viewClientCardDetailsBeanList = cardGeneralService.findLatestViewAccountCardDetailsBeanForEachCardType(accountNo);
        if (CollectionUtils.isEmpty(viewClientCardDetailsBeanList)) {
            return null;
        }
        ViewAccountCardDetailsBean physicalCard = viewClientCardDetailsBeanList.stream().filter(e -> StringUtils.equals(CardConstant.PHYSICAL, e.getCardType())).findFirst().orElse(null);
        if (physicalCard == null) {
            return null;
        }

        CardApplicationBean cardApplicationBean = cardGeneralService.getCardApplicationBean(physicalCard.getCardApplicationId());
        CardShippingBean cardShippingBean = cardGeneralService.getCardShippingBean(physicalCard.getCardApplicationId());
        return cardMapper.mapCardApplicationAndCardShippingBeanToModel(cardApplicationBean, cardShippingBean, physicalCard.getCardId());
    }

    @SneakyThrows
    public String getDecryptedJsonString(String pin) {
//        AESUtil aesUtil = new AESUtil();
//        return aesUtil.decryptToken(pin, secretKeyConfig.getSecretKey());
        return pin;
    }

    private boolean isSequential(String pin) {
        for (int i = 0; i < pin.length() - 1; i++) {
            int curr = Character.getNumericValue(pin.charAt(i));
            int next = Character.getNumericValue(pin.charAt(i + 1));
            if ((next != (curr + 1) % 10) && (next != (curr + 9) % 10)) {
                return false;
            }
        }
        return true;
    }

    private boolean matchesDobPattern(String pin, AccountModel accountModel) {
        String year = String.format("%04d", accountModel.getDateOfBirth().getYear());
        String month = String.format("%02d", accountModel.getDateOfBirth().getMonthValue());
        String day = String.format("%02d", accountModel.getDateOfBirth().getDayOfMonth());

        String pattern1 = year.substring(2) + month + day;
        String pattern2 = month + day + year.substring(2);
        String pattern3 = day + month + year.substring(2);
        String pattern4 = year + month.charAt(0) + day.charAt(0);
        String pattern5 = year.substring(2) + month + day.charAt(0);

        return pin.equals(pattern1) || pin.equals(pattern2) || pin.equals(pattern3)
                || pin.equals(pattern4) || pin.equals(pattern5);
    }
}
