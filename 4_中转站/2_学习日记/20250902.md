Security study


先看 my-core my-bond my-web 各3 个 Repo，看看他们都设置了什么 Security；然后再看 my-oauth 的 repo，写下 “有什么” 和 “他们怎么做” + “在哪里” 就可以了

Adjust screen- using joystick
My-web-fsmone
My-web-ifast

My-web-ifast-core ~ IfastWebSecurityConfigurerAdapter
@Override
public void configure(WebSecurity web) throws Exception {
    //Resources and scripts ignore
    web.ignoring().antMatchers("/app/**");
    web.ignoring().antMatchers("/assets/**");
    web.ignoring().antMatchers("/scripts/**");
    web.ignoring().antMatchers("/webjars/**");
    web.ignoring().antMatchers("/download/**");
    web.ignoring().antMatchers("/images/**");
    web.ignoring().antMatchers("/font/**");
}

IfastCspConfiguration
- cspPolicy
- reportingEndpoints
- legacyEndpoints

StaticHeadersWrite
CspHeaderWriter


CorsConfiguration




My-web-ifast
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.access.expression.WebExpressionAuthorizationManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final IfastLoginSuccessHandler ifastLoginSuccessHandler;
    private final IfastLoginFailureHandler ifastLoginFailureHandler;
    private final RestAuthenticationEntryPoint restAuthenticationEntryPoint;

    private final String socketWhitelistIp;
    private final String portalSimulationWhitelistIp;
    private final String whitelistIp;

    private final String[] REQUIRE_AUTHENTICATION;

    public SecurityConfig(
            IfastLoginSuccessHandler ifastLoginSuccessHandler,
            IfastLoginFailureHandler ifastLoginFailureHandler,
            RestAuthenticationEntryPoint restAuthenticationEntryPoint,
            String socketWhitelistIp,
            String portalSimulationWhitelistIp,
            String whitelistIp,
            String[] REQUIRE_AUTHENTICATION
    ) {
        this.ifastLoginSuccessHandler = ifastLoginSuccessHandler;
        this.ifastLoginFailureHandler = ifastLoginFailureHandler;
        this.restAuthenticationEntryPoint = restAuthenticationEntryPoint;
        this.socketWhitelistIp = socketWhitelistIp;
        this.portalSimulationWhitelistIp = portalSimulationWhitelistIp;
        this.whitelistIp = whitelistIp;
        this.REQUIRE_AUTHENTICATION = REQUIRE_AUTHENTICATION;
    }

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .headers(h -> h
                .frameOptions(fo -> fo.sameOrigin())
                .httpStrictTransportSecurity(hsts -> {})
            )
            .cors(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable())
            .formLogin(form -> form
                .loginProcessingUrl("/rest/login")
                .successHandler(ifastLoginSuccessHandler)
                .failureHandler(ifastLoginFailureHandler)
            )
            .logout(lo -> lo
                .logoutUrl("/rest/logout")
                .logoutSuccessHandler(ifastLogoutSuccessHandler())
            )
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(restAuthenticationEntryPoint)
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/rest/web/socket/**")
                    .access(new WebExpressionAuthorizationManager(socketWhitelistIp))
                .requestMatchers("/rest/web/authority/token/simulate")
                    .access(new WebExpressionAuthorizationManager(portalSimulationWhitelistIp))
                .requestMatchers("/**")
                    .access(new WebExpressionAuthorizationManager(whitelistIp))
                .requestMatchers(REQUIRE_AUTHENTICATION)
                    .authenticated()
            )
            .requiresChannel(ch -> ch
                .anyRequest().requiresSecure()
            )
            .sessionManagement(sm -> sm
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .addFilterBefore(setRequestFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilterBefore(getCustomCorsFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilterBefore(securityKeyAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilterBefore(getSameSiteCookieFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilterAfter(new PortalSimulationFilter(
                    "/**/read", "/**/list", "/**/validate", "/**/download",
                    "/**/search", "!/**/protected/**"),
                JwtAuthenticationFilter.class
            );

        HttpHeaderSecurityUtil.defaultHeaderSecurity(http);
        return http.build();
    }

    private IfastLogoutSuccessHandler ifastLogoutSuccessHandler() {
        return new IfastLogoutSuccessHandler();
    }

    private SetRequestFilter setRequestFilter() {
        return new SetRequestFilter();
    }

    private CustomCorsFilter getCustomCorsFilter() {
        return new CustomCorsFilter();
    }

    private JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }

    private SecurityKeyAuthenticationFilter securityKeyAuthenticationFilter() {
        return new SecurityKeyAuthenticationFilter();
    }

    private SameSiteCookieFilter getSameSiteCookieFilter() {
        return new SameSiteCookieFilter();
    }
}

- GetSameSiteCookie
- Oauth
- SetRequestFilter
- CustomCorsFilter
- JwtAuthenticationFilter
- UsernamePasswordAuthenticationFilter


My-web-fsmone
web.ignoring().antMatchers("/scripts/**");
- Ignoring 后面的网址不会经过 Spring Security Filter Chain
- But Spring Security 6 的常见做法是 requestMatchers().permitAll()


- OauthAuthenticationFilter
- Akamai (CDN)
- Cors

Before
http.cors()
		.and().csrf().disable()
		.formLogin()
		.loginProcessingUrl("/rest/login")
		.successHandler(fsmLoginSuccessHandler)
		.failureHandler(fsmLoginFailureHandler)
		.and().logout().logoutUrl("/rest/logout").logoutSuccessHandler(fsmLogoutSuccessHandler())
		.and().exceptionHandling().authenticationEntryPoint(this.restAuthenticationEntryPoint)
		.and().authorizeRequests()
		.antMatchers("/**").permitAll()
		.and().requiresChannel().anyRequest().requiresSecure()
		.and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);


After:
@Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable())
            .formLogin(form -> form
                .loginProcessingUrl("/rest/login")
                .successHandler(fsmLoginSuccessHandler)
                .failureHandler(fsmLoginFailureHandler)
            )
            .logout(logout -> logout
                .logoutUrl("/rest/logout")
                .logoutSuccessHandler(fsmLogoutSuccessHandler())
            )
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(restAuthenticationEntryPoint)
            )
            .authorizeHttpRequests(auth -> auth
                .anyRequest().permitAll()
            )
            .requiresChannel(channel -> channel
                .anyRequest().requiresSecure()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            );
        return http.build();
    }

- requiresChannel: Forcing HTTPS instead of HTTP
- CommonsMultipartResolver
- CorsConfigurationSource
    - allowedOrigin
    - allowedMethods
    - allowedHeader = CorsConfiguration.ALL
    - registerCorsConfiguration

— 
Till 10:45a.m., 35:40
- Till 12:29p.m., 1:19:58
- Till 1:40p.m. 44:28
- Till 4:29p.m., 2:27:53
- Till 4:56p.m., 18:22
深入学习
- my-oauth-ws
- my-web-fsmone
- my-web-ifast
- my-web-ifast-core
- my-partner-ws

了解各个 Filter 的基本配置和关联，还有其他的可能配置
目前结论：
- 有 Ctrl （Controller）的才有 security config；逻辑层是没有的
- 之前应该是没有 Feign Client，所以他们都是用 restTemplate 进行请求，比如 my-web-fsmone/service 的 AccountService，调用的也是 my-web-core 的 OauthTokenRestBaseService，而这个 Service 本质上也是通过 RestTemplate 进行跨 Service 请求
- 他们的基本 Naming 是：RestBaseService，然后这个 RestBaseService 是 my-modular-client 的一个类，封装了 Headers，Entity，RestTemplate，Uri，ResponseEntity 的各类逻辑，然后还有一系列的 Constants，作为没有 Service Discovery，Registry 和 Feign/gRPC 的通信机制
- 目前的话 ifastpay 也是没有这样一个 Service Registry & Discovery 的机制，所以都是通过 base.url 来进行通信；里面的 FeignClient URL/Name/path/configuration 都可以好好看下，有学习价值。

My-web-fsmone 探索（config & config/security/）
- config/
    - WebApplicationConfig（这里其实还有很多 Cross-service Configuration，但是暂时先不深究，这次的主要目的是学习下面的核心思路，这个其实也是 SecurityFilterChain 来的，但是可以先不看：Fall under my-web-core as well）。基本上有任何核心的逻辑都可以直接看 my-web-core；其他的通常都是配置而已。 
    - 有没有一种可能可以做 Bean Checking instead of logger.info for logging if a bean is initiated? Is there any better way of handling this?
    - CorsFilter
        - Introduction to Cors
            - https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS
            - A browser rule that controls whether a page at Origin A can call an API at Origin B. Without CORS, browsers block cross-origin reads to protect users.
            - For “non-simple” requests, the browser first sends a preflight OPTIONS request; server answers with Access-Control-Allow-Methods, Access-Control-Allow-Headers, etc. Only then does the browser send the real request. 第二层问题：什么是 Preflight Options request？
            - 所以 csrf.disable 是允许 Cross Site 还是不允许？如果不允许的话，要怎么发送请求？
            - 什么是 CrossOrigin？
            - 疑惑：为什么他们还要自己 Define 一个 CorsFilter？在配置了 http.cors(), CorsConfigurationSource 且 org.springframework.web.filter.CorsFilter 都已经可以通过 CorsConfigurationSource 和 CorsProcessor 进行处理了（源码有写。。。） 不理解，不深究，纯祝福 ：）
        - 问题：所以 CORS enable 是为了让 browser 可以访问 localhost？这就是为什么 Postman 可以 penetrate 吗？Then 这个 origin 是什么意思？为什么 browser 和 localhost 不是同个 origin？
        - 
    - AkamaiResposeFilter
        - Introduction to Akamai
            - Akamai is one of the world’s largest CDN providers (Content Delivery Network). Think of it as a global network of servers that sit between your users and your website/application to make delivery faster and safer.
            - What a CDN like Akamai does?
                - Speed up content delivery
                - Reduce server loads
                - Improve availability
                - Add security (mitigate DDoS attacks and WAF Web Application Firewall, and enforce HTTPS everywhere)
        - Technical (Code)
            - 下面这两玩意啥用？
                - ContentCachingRequestWrapper
                - ContentCachingResponseWrapper
                - 补充知识
                    - Servlet Filters（jakarta.servlet.Filter, CorsFilter, OncePerRequestFilter to avoid multiple execution)
                        - For low-level cross cutting concerns, such as logging, security checks, CORS, etc.
                        - To modify all requests including static files, errors, etc.
                    - HandlerInterceptor
                        - Spring-specific, sits after filters but before controllers
                        - It works in DispatcherServlet Pipeline. 
                        - It is used for controller-specific cross-cutting logic (auth checks, metrics, locale setup, etc.)
                        - Works with model/ headers only but not response body
                        - RequestBodyAdvice/ResponseBodyAdvice/ ResponseEntityExceptionhandler + ControllerAdvice/RestControllerAdvice
                            - Used to modify/inspect JSON/XML payloads, such as adding metadata, encryption/ decryption
                        - ControllerAdvice
                            - @Exceptionhandler, @InitBinder, @ModelAttribute
                        - Others
                            - HandlerMethodArgumentResolver (@RequestParam, @PathVariable, etc.)
                            - HandlerMethodReturnValueHandler
                            - HttpMessageConverter
                            - ServletRequestWrapper, ServletResponseWrapper
                            - ExceptionResolver
                - Filter -> GenericFilterBean -> OncePerRequestFilter 什么是 multiple execution？any example？为什么会有 multiple execution？OncePerRequestFilter 怎么解决这个问题？（It sets a request attribute marker so even if the request is forwarded internally, the filter won’t run again. Provides an abstract doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain) → you don’t have to cast yourself.
    - security/
        - WebSecurityConfig/
        - SetRequestFilter
        - OAuthAuthenticationFilter
        - （logout/login）
            - FsmAuthenticationProvider
            - FsmGrantedAuthority（注）
                - 原来 GrantedAuthority 只是一个 Interface，平常用的都是 SimpleGrantedAuthority，却从来没想过使用自定义的…, but 这里 define 的其实也不难，就是拿一个 constant 放进去而已。。。现在我的 难题是：有 business logic yet it is shared/ not good to scatter around的 constant 放哪里。。。
            - FsmUserDetails
            - FsmLoginFailureHandler
            - FsmLoginSuccessHandler
            - FsmLogoutSuccessHandler

Reply to Wei Li

Alright sure. But may I confirm that if the on the current workflow, is it Requirement Gathering (M1, M2-solution design, M3, M4) -> Solution Planning -> Internal Review (Involving only senior ITs) -> Comprehensive Review (Involving all stakeholders)-> Development? 

If yes, may I know is there any differences between “solution design” and “solution planning”? Or they can be used interchangeably? If they are different concepts, should be included in the solution design?

My current concern is that since the requirements are still being gathered, it seems like I have no idea to proceed with the “solution design/planning” for this upcoming M2 meeting, or I actually just need to attend and gathers the requirements only?

As previously when I dealing with “solution design/planning”, it is more technical side, like how the system works from upstream to downstream, how the solution changes the system interaction, what configuration/code should be amended, etc. So from my current pot, the solution design cannot proceed without clear requirements as it might be subjected to frequent changes. Please correct me if I’ve misunderstood  it.

So it would be nice if you could let me know what should I prepare for the upcoming M2 meeting beside a list of questions for the requirement gatherings (M2, M3, M4).

— 代码收录
        ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request);
        ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response);

        filterChain.doFilter(requestWrapper, responseWrapper);

        try {
            String responseString = IOUtils.toString(responseWrapper.getContentInputStream(), StandardCharsets.UTF_8);

            if (StringUtils.isNotEmpty(responseString)) {
                JsonNode responseJson = objectMapper.readValue(responseString, JsonNode.class);
                JsonNode responseStatusNode = responseJson.get("status");
                final String responseStatus = responseStatusNode.asText();
                boolean isSuccess = StringUtils.equalsIgnoreCase(responseStatus, "SUCCESS");
                Cookie cookie = generateResponseCookie(isSuccess);
                responseWrapper.addCookie(cookie);
                ResponseUtil.appendResponseHeader(response, isSuccess);
            } else {
                Cookie cookie = generateResponseCookie(false);
                responseWrapper.addCookie(cookie);
                ResponseUtil.appendResponseHeader(response, false);
            }
        } catch (Exception exception) {
            logger.error("Error while attempting to retrieve response status: ", exception);
            Cookie cookie = generateResponseCookie(false);
            responseWrapper.addCookie(cookie);
            ResponseUtil.appendResponseHeader(response, false);
        }

        responseWrapper.copyBodyToResponse();
    }


After
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {
    if (!URI_ADD_AKAMAI_RESPONSE.contains(request.getServletPath())) {
        filterChain.doFilter(request, response);
        return;
    }

    ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request);
    ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response);

    filterChain.doFilter(requestWrapper, responseWrapper);

    boolean success = false;
    try {
        String responseString = responseWrapper.getContentAsString(StandardCharsets.UTF_8);
        if (StringUtils.isNotBlank(responseString)) {
            JsonNode responseJson = objectMapper.readTree(responseString);
            success = "SUCCESS".equalsIgnoreCase(responseJson.path("status").asText());
        }
    } catch (Exception e) {
        logger.error("Error reading response JSON", e);
    }

    Cookie cookie = generateResponseCookie(success);
    responseWrapper.addCookie(cookie);
    ResponseUtil.appendResponseHeader(responseWrapper, success);

    responseWrapper.copyBodyToResponse();
}


尼玛等级直接不一样。。。或者下面这种也行：

@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {
    if (!URI_ADD_AKAMAI_RESPONSE.contains(request.getServletPath())) {
        filterChain.doFilter(request, response);
        return;
    }

    ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request);
    ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response);

    filterChain.doFilter(requestWrapper, responseWrapper);

    boolean success = false;
    try {
        String responseString = responseWrapper.getContentAsString(StandardCharsets.UTF_8);
        if (StringUtils.isNotBlank(responseString)) {
            JsonNode responseJson = objectMapper.readTree(responseString);
            success = "SUCCESS".equalsIgnoreCase(responseJson.path("status").asText());
        }
    } catch (Exception e) {
        logger.error("Error reading response JSON", e);
    }

    Cookie cookie = generateResponseCookie(success);
    responseWrapper.addCookie(cookie);
    ResponseUtil.appendResponseHeader(responseWrapper, success);

    responseWrapper.copyBodyToResponse();
}

- Advantages：
    - No buffering → we get the response object directly, not raw bytes.
    - Cleaner logic → runs only when a controller returns a body (filters run for everything, even static assets).
    - Easier maintenance → no need for ContentCachingResponseWrapper.
    - Safer JSON parsing → object already deserialized by Jackson, so we just re-map to JsonNode.


Vim
- Ctrl f = one page down
- Ctrl b = one page backward
- Ctrl d = half page down
- Ctrl u = half page up
- Zz = middle
- Zt = top
- zb= bottom


Authorization Issue

@ConditionalOnProperty(
        value="redis.enabled",
        havingValue = "false",
        matchIfMissing = false
)

https://igb-ndbs-bo-uat.ifast-aws.com/main/administration/user-management/role-rights

https://igb-ndbs-bo-uat.ifast-aws.com/main/administration/user-management/role-rights


