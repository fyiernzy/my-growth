25 September

产出（记录）
1. 整理了 SAS 提供的 Client Authentication Method，并做成了 MB_AUTH_Client Authentication Method，发在群里等待大家回复。

产出（文件）
1. MB_AUTH_Client Authentication Method
2. chatGPT 命名规则: <date>-<type>-<name>


代办
- [ ] 项目
    - [ ] 基础学习（基础能用）
        - [ ] Mechanism: Retry, Rate limiting
        - [ ] Spring Cloud Gateway
        - [ ] Spring Cloud LoadBalancer
        - [ ] Spring Cloud Circuit Breaker
        - [ ] Spring Cloud Config
        - [ ] Spring Cloud Modulith
        - [ ] Spring Actuator
    - [ ] 深入学习（高可用性质）
        - [ ] Spring Cloud OpenFeign
        - [ ] Spring Security, Spring Session
        - [ ] Spring Data, Spring Data JPA, Spring Data JDBC
        - [ ] Observability
        - [ ] Service Registry & Service Discovery (with Eureka)
        - [ ] MapStruct, Lombok (configuration)
    - [ ] 学习原理
        - [ ] Spring Security
        - [ ] Spring Authorization Server (Videos + Docs)
    - [ ] 功能
        - [ ] 登录 & 认证

思路
- 先了解有什么功能，能做什么
- 然后选取自己想要的功能写成 TODO
- 去实现 + 测试

- Gateway
    - Need: 
        - Routing via Eureka
        - Filtering: pre-filters, post-filters
            - Add/modify headers/query params
            - Rewrite path
            - Authentication & Authorization
        - Resilience:
            - Circuit Breaking
            - Retries
            - Timeouts
            - Fallbacks
        - Rate limiting: User, IP, API KEY
        - Observability (micrometer, prometheus)
- LoadBalancer
    - Need:
        - Traffic Distribution: (wit different algorithms)
        - Health-checking
        - Sticky sessions/ Session Persistence
        - Observability:
- Config
    - Centralized config management (fetch & startup & refresh and runtime)
    - Environment & profile awareness
    - Dynamic refresh of configuration (actuator/ spring cloud bus)
    - Verson & auditable config
    - Encryption & description
    - Multi-source support
    - Bootstrap integration
    - Client-side failover
    - 动态配置
- Modulith
- Open Feign
    - Out-of-the-box: Service Discovery, Load Balancing, 
    - Need: Circuit Breaking, Retries, Fallback, Timeouts, Logging levels, retry policy, metrics
    - No need: Request interceptors
- Eureka
    - Server
        - Peer replication
        - Self-preservation & eviction
        - Lease timings
        - Registry cache
        - Metadata
        - Security
    - Client
        - Discovery behaviour
        - Lease timings
        - Eureka URL (zone/region)
        - Instance Identity & network
        - Health integration
- Circuit Breaker + Resilience4j
    - Circuit Breaker
    - Retry
    - Rate Limiter
    - Time Limiter
    - Bulkhead
    - Fallbacks
    - Cache
    - Metrics
- Spring Cloud Gateway RateLimiter
- Spring Cache (with Caffeine)
    - Declarative Annotations (Go through)
    - Programmatic API (Go through)
    - Eviction Strategy, conditional cache, multi-operation combos
    - Null caching, transaction awareness, error handling, metrics & observability
- Spring Actuator

Use both—but for different goals:
* If the filter is meant to run inside Spring Security’s chain (e.g., request blocking, auth-related prechecks): Best practice: Provide the filter as a bean (for DI & testing) and also provide a FilterRegistrationBean for it with setEnabled(false) so Spring Boot does not auto-register it with the servlet container. Then place it explicitly with addFilterBefore/After(...) on your SecurityFilterChain.
* If the filter is meant to run globally at the servlet container level (e.g., access logging, gzip, correlation IDs unrelated to security order): Best practice: Register it via FilterRegistrationBean (enabled, URL patterns, order) and do not add it to the Security chain.
