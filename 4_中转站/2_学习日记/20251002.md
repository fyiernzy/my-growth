2 October

TODO

Gateway & Mechanism:
1. RequestSginging
2. Auth Server
3. SystemSetupervice
4. SecretKeyService (Need study underlying mechanism)

Consistency for all GatewayFilters (Conventions, codingg style)
1. Config, private method, naming, encryption/ decryption logic, etc.


Today‚Äôs Work
1. Filters (Logic)
2. Filters Testing
3. Observability (Coverability)
4. Security, Resilience, Feign
    1. Resilience
        1. Fallback, FeignClientRetryer, Rate Limiting
- [x] SecurityUtils + Base64Utils + EncryptionUtils, JsonUtil
1. Testing
    1. Can work
    2. Can work properly
    3. Can work efficiently
    4. Infrastructure: EnableFiltersSupport
2. Others
    - [ ] Token Relay
    1. PropertiesLogger
    2. DefaultConfig
    3. StopWatchUtil
3. Convention

HTTP Interface Client vs Feign Client

Documentation
1. The OAuth2 mechanism in the existing codebase (create token, check token, refresh token)
2. How to read the code of FSM, iGB and iGV (With GitLab link provided)
3. Introduction to Spring Security (Authentication & Authorization) with demo code, testing, and source code reading
4. Conventions & Cheatsheet for Spring Cloud Gateway and Spring Security/ SAS

Gateway
1. Framework
2. Observability (Metrics, Logging, Tracing)
    1. What to ‚Äúobserve‚Äù
    2. How to see these ‚Äúobservations‚Äù?
    3. Industry practices
3. Security
4. Resilience
5. Testing
    1. How to perform testing on Spring Cloud Gateway
    2. Utils
        1. RequestWrapper,
        2. 
6. Study/ Documentation
    1. Mono, Flux (Reactive concepts + Demo & Practices)
    2. Convention & Cheatsheet

Authentication
- Compile the current knowledge
- Internal Service Authentication
- Token Exchange changes & mechanism

Gateway
1. Development (+ Well documented + Testing Docs)
    1. Gateway Filters
    2. Global Filters
        1. Observability (Traces, Metrics, Logging)
            1. HttpMetricFilter + Study industry practices
    3. Testing
        1. Testing Service 
        2. Auth Service
    - Current Approach & Suggested Approach of FxtsWays

References
    1. Services
        1. RequestSigningService
1. Integration-api-ws
    1. Filters
        1. Decryption
            - [x] RequestBodyDecryptRewrite
            - [x] RequestParamDecryptionGatewayFilter
            - [x] ResponseBodyDecryptionRewrite
        2. Encryption
            - [x] RequestBodyEncryptionRewrite
            - [x] RequestEncryption
            - [x] RequestParamEncryption
            - [x] ResponseBodyEncryptionRewrite
    2. Support oath token flexibility (but it should be)
    3. FeignClientRetryer
    - [x] SecretkeyService
    1. ApiConstant
    2. OpenFeignPathConstant
    3. OAuthController
    4. EncryptionUtil
    5. OZoneApiResponseBodyRewrite
    6. ValidationGlobalFilter
    7. SumsubWebhookFilter

Next step:
1. Configure Micrometer, Prometheus, OpenTelemetry + Feign (Retry + Fallback) for Observability
2. Complete the Utils
3. Keep the useful constants and find alternative
- [ ] Testing on Gatewayfilters/ Global Filters 

Auto Import
Manual Import

Security
1. Documentation
    1. Type: Discovery
        1. Provides a document that links to all other documents
    2. Type: Security
        1. In the document, provide the exact version of Spring Security, SpringBoot, Spring Cloud Gateway, Spring Authorisation Server, Spring OAuth Client, Spring OAuth Resource version to be used.
        2. Study the available algorithms and the industrial standard for client secret generation and encryption with its configuration setup.
        3. Include any RFC/ OWASP/ OAuth2.0 resources to improve the credibility.
        4. API Specification (What are exposed, what are hidden, how they are hidden, justification and explanation).
        5. Token Settings & Client Settings & Justification (Default, Stricter, Looser) 
        6. How IAM service can be provided and what‚Äôs its roles.
    3. Type: Guideline/ Study
        1. Draw a Sequence Diagram to illustrate how other internal services and external services could request for the token (Create/ Refresh Token)
            1. Client Side
            2. Internal Mechanism Study
        2. Encryption Algorithm & Study
    4. Type: Solution Design/ Convention/ Guideline/ Demo
        1. How to perform changes to SecurityFilterChain
        2. What are the convention available and why.
2. Code
    1. Type: Generator
        1. TokenSettings/ ClientSettings Generator
        2. Generate SQL from RegisteredClient
        3. Generate RegisteredClient from SQL
        4. Generate Client Secret/ Encryption
        5. Constants: Default Token Settings
    2. Type: Util

Testing
1. Gateway
2. Security


Exactly ‚úÖ ‚Äî when you use Ordered (either by:
* implementing Ordered,
* annotating with @Order, or
* wrapping in OrderedGatewayFilter),
the order value is the primary driver of execution order in Spring Cloud Gateway.

üîπ Ordering rules recap
1. Lowest order value runs first in pre-phase.
    * Ordered.HIGHEST_PRECEDENCE (Integer.MIN_VALUE) will always be the very first.
    * Larger numbers run later.
2. Post-phase runs in reverse.
    * Filter with lowest order runs last after the downstream handler.
    * Example:‚Ä®FilterA (order=1) ‚Üí FilterB (order=5) ‚Üí downstream
    * downstream ‚Üí FilterB post ‚Üí FilterA post
    * 
3. Ties (same order value):
    * If two filters have the same order, Spring preserves their registration order (YAML order for GatewayFilterFactory, or bean order for GlobalFilter).

üîπ Without Ordered / OrderedGatewayFilter
* For route filters: execution order follows the list order in your application.yml or DSL.
* For global filters: execution order is undefined unless you give them an explicit @Order or Ordered value.

‚úÖ So yes:
With Order, it will fully rely on the Order value.
The only caveat: if multiple filters share the same order value, then declaration order breaks the tie. Otherwise, order completely dictates the filter chain sequence.

Would you like me to draw you a timeline diagram showing how your CacheRequestBody (order = HIGHEST_PRECEDENCE), DecryptRequestBody (order = 1), and DecryptRequestParams (order = 1) would actually run in pre/post phases?


