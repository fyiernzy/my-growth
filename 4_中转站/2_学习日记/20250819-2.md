18082025

- Protect APIs from SQL injection, XSS, CSRF.
- Implement RBAC (Role-Based Access Control) and authentication.
- Encrypt sensitive data (passwords, payment info).
- Follow GDPR/PDPA compliance for user data.

- Write unit tests for critical business logic or functionalities that require additional verification (e.g., complex calculations, financial transactions, security-sensitive operations) using JUnit and Mockito.
- Implement integration tests for APIs & database operations.
- Maintain at least 80% test coverage.
- Conduct manual/automated testing to catch edge cases.

JWT/OAuth2 authentication, RBAC, SQL Injection XSS attacks, JPQL > Raw SQL, AES Encryption

HTTPS:, SSL Certificate, OAuth2.0, JWT, roles and permissions, rate limiting & throttling, avoid chatty APIs

AuditTrail (action, user, details)

- [ ] Token Exchange
    - [ ] Previous token exchange solution with Michael, understand requirements (FSM One)
    - [ ] R&D & Propose enhancement
    - [ ] Solutio planning
- [ ] Multi Session Handling
    - [ ] Ask for requirement backgrounds, JWT & Redis
- [ ] Transaction Monitoring
    - [ ] Get all client transactions monitoring class (iGB & IFast CAP for transaction monitoring)
    - [ ] Solution planning
- [ ] FSKM One Authentication Enhancement
    - [ ] Support for digital token (API)
    - [ ] API - session token, session handling, biometric & password
- [ ] Spring Security Setup

Resources
IT Main Sheet
https://sgnas.ifastfinancial.com/drive/oo/r/12QGjVNi5Ec4ufsvhjmYFsepYq8rp5yN

Notes
1. Why decentralised ifastpay back office system?
    1. Maintenance effort split between regions, reduce the cognitive load, improves efficiency and reduce technical debts
    2. Tailored features & regulatory requirements
    3. Easier local compliance updates
    4. Clear responsibility, prevent blame game amongst different teams
    5. Minimized regional interference 
    6. Minimized downtime effect
    7. Small cost to avoid a big fine


SOP for Module Development
- Requirement Analysis & Design
    - Requirement Gathering
        - Understand the business logic for the module
        - Define the input/output (API contract) & expected behaviour
        - Identify dependencies on other modules or external systems
    - Design documents
        - Define API specification (req/res format, status code)
        - Database changes (Tables, indexes, constraints)
        - Ensure security and performance considerations
    - Technical Review with the Team & Receive feedback
- Coding Standards & Best Practices
    - SOLID, DRY, KISS, Clean Code

Spring Security & Authentication
- [ ] Token Exchange

Project Work Plan
https://sgnas.ifastfinancial.com/drive/oo/r/13PeN0fRuHTp9ndsS3jV4hAZos9NjJ9Q

Secure File Upload (-whitelist file extension, validate file type (File Signature, not on content type, file name length limit, restrict allowed characters for filename to prevent path traversal, LFI, RFI, SSRF, RFD attacks)

File size limit- prevent DOS conditions due to insufficient disk space.

Stores files on a different server outside of the webfoot.
Only authorised users to upload files, to reduce the possible attack surface
Run the files through an antivirus or a sandbox if available
Make sure library for handling file upload is securedly configured and kept up to date


FilenameUtils from Apache
Content Disarm & Reconstruction (CDR) - jPDFOptimizer library

ACCESS POLITY & Auditing, the controller, Two factory authentication, approved, unfinished

RBAC - Rights (X roles, but rights) to access
@PreAuthroized, @SkipPreAuthorize
Centralized Configuration/ Backoffice for handling it?

Use strong, standardized algorithms from reputable libraries ** Regularly update cryptographic libraries to address known vulnerabilities
Implement proper key management and storage
Use secure random number generators for cryptographic operations
Avoid deprecated or weak cryptographic algorithms
Implement proper error handling to prevent information leakage

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import java.security.SecureRandom;
import java.util.Base64;


Think whether is there anyone doing it before or not

esource Limiting is an integral part of API security. It refers to an API's ability to adequately control the allocation and consumption of its resources. Failure to limit resources can lead to several issues such as:
* Denial of Service (DoS)
    * Without proper rate limiting, an API might be overwhelmed by too many requests in a short period, leading to service disruption or unavailability.
* Resource Exhaustion
    * APIs that do not limit the resources a single user or request can consume may face exhaustion of system resources like memory, CPU, or network bandwidth, affecting overall service performance.
* Security Breaches
    * Attackers could exploit this vulnerability to perform brute-force attacks on endpoints, potentially leading to unauthorized access or data exposure.

Execution time
https://owasp.org/API-Security/editions/2019/en/0xa4-lack-of-resources-and-rate-limiting/

o prevent such vulnerabilities, it's important to implement measures like execution timeouts, request size limits, and rate limiting to ensure that the API can handle the load without compromising service integrity. Here are some strategies to mitigate this issue:
1. Rate Limiting Define proper rate limits to control how often a client can call the API within a defined timeframe.This helps prevent abuse and ensures fair usage among all clients.
2. Payload Size Limits Enforce limits on the size of request payloads to prevent large data transfers that could overwhelm the system.
3. Resource Allocation Limits Set maximum limits on resources such as memory, CPU, file descriptors, and processes that an API can use.This can be done at the server level or using container technologies.
4. Execution Timeouts Implement execution timeouts to ensure that API requests do not hold onto resources for too long, potentially blocking other requests.
5. Quotas and Throttling Establish quotas for API usage and apply throttling as necessary to control the consumption of server resources and prevent overuse.
6. Input Validation Add server-side validation for query string and request body parameters, especially those that control the number of records returned in a response.
7. Third-party Service Limits If your API integrates with third-party services, set spending limits to avoid unexpected costs due to excessive API calls.

.1. How To Prevent Excessive Data Exposure
1. Limit Data Output Only provide the essential data that clients require for their operations.
2. Filter Sensitive Information Implement robust server-side filtering to strip out sensitive data before it reaches the client.
3. Apply Role-Based Access Ensure users only access data that their roles are authorized to view.
4. Validate Responses Against Schema Use predefined schemas to validate API responses, ensuring they don't contain extra data.


import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.stereotype.Component;

@Component
public class SensitiveDataFilter implements BeanPostProcessor {

    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        if (bean instanceof MappingJackson2HttpMessageConverter) {
            MappingJackson2HttpMessageConverter converter = (MappingJackson2HttpMessageConverter) bean;
            converter.setObjectMapper(objectMapper);
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        if (bean instanceof MappingJackson2HttpMessageConverter) {
            MappingJackson2HttpMessageConverter converter = (MappingJackson2HttpMessageConverter) bean;
            SimpleFilterProvider filterProvider = new SimpleFilterProvider();
            filterProvider.addFilter("sensitiveDataFilter",SimpleBeanPropertyFilter.serializeAllExcept("password", "ssn"));
            objectMapper.setFilterProvider(filterProvider);
        }
        return bean;
    }
}

import com.fasterxml.jackson.annotation.JsonFilter;

@JsonFilter("sensitiveDataFilter")
public class User {
    private String username;
    private String password; // Will be filtered out
    private String ssn;      // Will be filtered out
    // Other fields and methods
}

To ensure no unintended actions are performed by the database engine, great care has to be taken to encode the parameters properly to avoid the following consequences:
* Unauthorized viewing of user data
* The deletion of entire tables
* Unauthorized assignment of administrative rights
* Malicious takeover the database and underlying serve

Do not directly construct dynamic queries using user supplied input, which may contain malicious SQL that could affect the logic of the executed query. Ensure one or more of the following is practiced:
* Use Prepared Statements (with Parameterized Queries)
* Use Stored Procedures
* Use Allow-list Input Validation
* Escape All User Supplied Input

Do not directly construct dynamic queries using user supplied input, which may contain malicious SQL that could affect the logic of the executed query. Ensure one or more of the following is practiced:
* Use Prepared Statements (with Parameterized Queries)
* Use Stored Procedures
* Use Allow-list Input Validation
* Escape All User Supplied Input


Malicious actors may try to submit data that will be included as part of a JSON string that may be parsed later in other parts of the application. Take the following JSON string as an example:
{
  "qualification": "BSc",

  "grade": "First Class."
}
Assuming the parameter "grade" is a user input, if not sanitized or validated properly, the following malicious JSON could be generated:
{

"qualification": "MSc",

"grade": "First Class."});alert(1);({"qualification":"MSc","grade":"Distinction."

}


LDAP queries submitted to the server are known as LDAP search filters, which are constructed using prefix notation. Below is an example of an LDAP search filter:
find("(&(cn=" + username +")(userPassword=" + pass +"))")
This prefix filter notation instructs the query to find an LDAP node with the given username and password. Consider a scenario where this query is constructed by appending the username and password strings obtained from an HTML form. If these user-controlled values are appended to the LDAP search filter without any validation or sanitization, a username and password value of ‘*’ changes the intended meaning of the query and returns a list of all users.
Special characters other than ‘*’ can also create malicious queries. If the username value is set to ‘*)(cn=*))(|(cn=*’, the effective search filter becomes:
find("(&(cn=*)(cn=*))(|(cn=*)(userPassword=" + pass +"))")
The condition in the above query always evaluates to true. If this query is used within an authentication flow, an attacker can easily bypass authentication controls with the above payload.
There are a multitude of LDAP injection exploits that can be executed against a vulnerable server. Additionally, LDAP servers often store information such as users, roles, permissions, and related objects provisioned to them which, if compromised, can be devastating.

If malicious inputs are not sanitized or validated properly before inserting them as part of XML content, they might break the XML syntax potentially causing an error, or even change the XML structure. Consider the following example scenario, where the input 'id' and 'quantity' is used as attributes to construct an XML:
Consider this URL: http://example.com/add_to_cart.svdo?item=5&quantity=1
The following would be the resulting XML if no unusual input is used:
<addToCart>
      <item id="5" perItemPrice="50.00" quantity="1" />
    </addToCart>
Now, if the input is not sanitized or validated, it can be manipulated to change the cost of the item:
http://example.com/add_to_cart.svdo?itemId=5"+perItemPrice="0.00"+quantity="100"+/><item+id="5&quantity=0
Resulting in the following XML:
<addToCart>
      <item id="5" perItemPrice="0.00" quantity="10" />
      <item id="5" perItemPrice="50.00" quantity="0" />
 </addToCart>
Note: XPath Injection and XXE attacks works similarly.

If the application relies on user input or client-side data as references to retrieve resources, the application may be vulnerable to file inclusions (LFI/RFI) or path traversal attacks. Consider the following example URL which retrieves the page reference by the 'path' parameter and displays it to the user:
http://example.com/view_page.svdo?path=content%2Fthispage.html
If the path parameter is not validated (against a whitelist or otherwise), an attacker may be able to ask the server to fetch any files they want by changing the parameter value. For example, the following URL may retrieve the system file /etc/passwd from the server and disclose the list of valid users on the system:
http://example.com/view_page.svdo?path=../../../../etc/passwd

JSON Injection Escape the double quote (") and backslash () characters in any input received before appending them as part of a JSON string. Special values in JSON are escaped by adding a backslash before the escaped character. Besides double quote and backslash, the following should also be escaped: 
* Backspace to be replaced with \b
* Form feed to be replaced with \f
* Newline to be replaced with \n
* Carriage return to be replaced with \r
* Tab to be replaced with \t

Also try to use JSON.parse instead of eval() to parse JSON strings to prevent code injection attacks. LDAP Injection Make sure to encode or escape the following characters: \ # + < > , ; " = and leading or trailing spaces and also the forward slash (/) in DN. Escaping is done via the backslash () character. XML Injection Escape the following characters:
* " to be replaced with &quot;
* ' to be replaced with &apos;
* < to be replaced with &lt;
* > to be replaced with &gt;
* & to be replaced with &amp;

However, certain characters may not need to be escaped depending on which part of the XML document the data is used in. Path Traversal Attacks Unfortunately, there are not a universal set of characters to be encoded due to the lack of interoperability across different Operating Systems, file protocols, etc. However, when dealing with file names or paths, it is generally accepted that at least the following characters should be sanitized:
* Slashes: \ / 
* Period or Full Stops: . 
Due to the difficulty of encoding file names and paths, emphasis is placed on the validation instead when it comes to preventing path traversal attacks.


However, it is not recommended to perform the sanitization or encoding manually if possible. Generally, they should be handled by a well-tested library or a built-in function of any programming language if available.

The OWASP JSON Sanitizer Project is a simple to use Java library that can be attached at either end of a data-pipeline to help sanitize JSON contents. When given JSON-like content, the JSON Sanitizer converts it to valid JSON. It is available at:

import com.google.json.JsonSanitizer; //after installing via Maven or package manager

...

String wellFormedJson = JsonSanitizer.sanitize(myJsonLikeString);

https://www.comparitech.com/net-admin/json-injection-guide/
https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html
https://www.synopsys.com/glossary/what-is-ldap-injection.html
https://github.com/owasp/json-sanitizer
https://ldapwiki.com/wiki/DN%20Escape%20Values
http://www.ietf.org/rfc/rfc4627.txt
https://commons.apache.org/proper/commons-lang/javadocs/api-3.3/org/apache/commons/lang3/StringEscapeUtils.html
https://www.tabnine.com/code/java/methods/org.apache.commons.text.StringEscapeUtils/escapeXml11
https://jsparrow.github.io/rules/use-parameterized-ldap-query.html

Brute force protection restricts the number of login attempts within a specified period. Implementing brute force protection for authentication can significantly mitigate the risk of unauthorised access, protect user accounts and maintain the integrity of the authentication process.

Implement anti-automation checks. (e.g. Captcha)
Apply rate limiting for login attempts.
Incorporate progressive incremental time delays (e.g. 30 seconds, 1 minute, 2 minutes, 5 minutes) for login attempts.
Enforce account lockouts.

@Service
public class LoginAttemptService {
    private final int MAX_ATTEMPT = 5;
    private LoadingCache<String, Integer> attemptsCache;

    public LoginAttemptService() {
        super();
        attemptsCache = CacheBuilder.newBuilder().
        expireAfterWrite(1, TimeUnit.DAYS).build(new CacheLoader<String, Integer>() {
            public Integer load(String key) {
                return 0;
            }
        });
    }

    public void loginFailed(String key) {
        int attempts = 0;
        try {
            attempts = attemptsCache.getkey;
        } catch (ExecutionException e) {
            attempts = 0;
        }
            attempts++;
            attemptsCache.put(key, attempts);
    }

    public boolean isBlocked(String key) {
        try {
            return attemptsCache.getkey >= MAX_ATTEMPT;
        } catch (ExecutionException e) {
            return false;
        }
    }
}

@Component
public class AuthenticationFailureListener implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {
    @Autowired
    private HttpServletRequest request;
    @Autowired
    private LoginAttemptService loginAttemptService;

    @Override
    public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent e) {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader == null) {
            loginAttemptService.loginFailed(request.getRemoteAddr());
        } else {
            loginAttemptService.loginFailed(xfHeader.split(",")[0]);
        }
    }
}


public class CustomAuthenticationProvider extends DaoAuthenticationProvider {
    @Autowired
    private LoginAttemptService loginAttemptService;

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        String username = authentication.getName();
        if (loginAttemptService.isBlocked(username)) {
            throw new LockedException("User account is locked");
        }
        return super.authenticate(authentication);
    }
}

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private CustomAuthenticationProvider customAuthProvider;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) {
        auth.authenticationProvider(customAuthProvider);
    }
// Other security configurations
}

ErrorResponse, ProblemDetails, Auditable(CreatedDate, CreatedBy, UpdatedDate, UpdatedBy)

Spring Security + Cache + Security Mechanism + Authentication & Authorization + Rate Limiting LETS GO Auditable

Naming
<Specific-Use>Constants.<GROUP>.<Name>

2FA, MFA
Access Policy
Roles & Rights 
- Rights: To access to different modules and APIs
- Roles: A group of rights given to a user.

- USER_ROLE: PK-username, FK-roleid
- ROLE: role-id, name, description, status
- Role right: role-id, right-id
- Right: Action(CRUD, Appove) , Module Id, description, category (submodule), category order, right id = CATEGORY_ACTION
- Module - name, order
- hasAuthority-constants
- @SkipPreAuthroize

Previously use SQL schema to add

Enums vs Constants

ROLE, ROLE_RIGHT, MODULE

Maker Checker


Valuable Study Resources
- iFAST Global Bank (iGB)
- https://sgnas.ifastfinancial.com/drive/oo/r/pYf2EMhofzhd5lNJsBOloNXgCffcFhc1#slide_id=mQ3r30qlC8
- iFastPay https://sgnas.ifastfinancial.com/drive/oo/r/12fP5mVlnbMvvb3WLCiV65P4Dn2H06Ih#slide_id=j1nb2EbF23


API Naming convention
- URL Versioning
    - /api/v1/<module>
    - Use nouns to represent resources and HTTP methods to define actions (GET, POST, PUT, DELETE), no verbs
    - Use OpenAPI (Swagger) for this purpose.
    - Standardize Success & Error Response (compatible with SpringBoot mechanism?)
        - Get a list of records
            - <Module>/bulk/enquiry
        - Get a specific record: <module>/enquiry
        - Validate: <module>/<type>-check
        - Create: <module>/<type>
* Avoid Retrieving Large Amounts of Data – Use pagination, filtering, and sorting to improve performance
* Efficient Querying - Standardize request body parameter like {filter: , sort: , page: & limit: }

* Graceful Degradation with Third-Party API Failures - Handle third-party failures with circuit breakers, retries, and fallbacks

3. JSON Naming Conventions
* Use camelCase for JSON field names (e.g., userName, orderCount).
* Avoid abbreviations – Keep names descriptive and consistent.

3. Optimize API Calls
* Reduce "Chatty" APIs – Return necessary data in a single call when possible.
* Use Batch Operations & Composite Endpoints – Minimize redundant requests.

https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides

https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods

https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers

https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status

https://owasp.org/API-Security/

model/
│ ── {domain}/
│   │── <Action><Object>RequestModel.java  → Defines request models for API actions (e.g., Create, Update)
│   │── <Object>ResponseModel.java  → Defines response models representing API response data
│   │── <Action><Object>Model.java  → Defines internal DTO for business logic transformation
│   │── <Object>Model.java  → Defines internal DTO for business logic transformation

MapStruct, componentModel, field injection (@Autowired through set), @Mapping, @BeanMapping, @Named, @AfterMapping

@Mapper(
Config = 
Uses = 
Other options…
}

domain/
│── entity/
│   │── {domain}/
│   │   ├── <TableName>Bean.java  → Defines database entity classes (tables)
│   │   ├── <ViewName>Bean.java  → Defines view entity classes (database views)
│
│── query/
│   │── {domain}/
│   │   ├── <TableName>Query.java  → Interface for complex queries on table entities
│   │   ├── <TableName>QueryImpl.java  → Implementation for complex queries on table entities
│   │   ├── <ViewName>Query.java  → Interface for complex queries on view entities
│   │   ├── <ViewName>QueryImpl.java  → Implementation for complex queries on view entities
│
│── repository/
│   │── {domain}/
│   │   ├── <TableName>Dao.java  → DAO interface for basic CRUD operations on table entities
│   │   ├── <ViewName>Dao.java  → DAO interface for basic CRUD operations on view entities

* Use singular nouns (e.g., account, card)
* Use snake_case for multi-word names (e.g., card_application)
* For modular applications, prefix tables with the module name (e.g., card_transaction).
* For composite (join) tables, combine the related table names in singular form, separated by an underscore (e.g., bo_user_role for bo_user and role).


Column Naming
* Use singular nouns (e.g., email)
* Use descriptive names (e.g., first_name instead of fname)

Column Purpose	Naming Convention	Example
Reference to past actions	Past tense, passive	approved_by, assigned_to
User reference	_by suffix	approved_by, updated_by
Historical event timestamps (with/without time)	Past tense + _at suffix	created_date, approved_date
Boolean conditions	is_ prefix	is_verified, is_enabled
State/status fields	Single status column: status
Multiple status columns:  Nouns + _status suffix	approval_status, payment_status
Ongoing processes	Present participle (-ing)	processing_status, loading_flag
A category/type of action	Infinitive (base verb)	action_type, event_trigger
ID primary key	id
 * Do not need to repeat table name for id prefix	id


Index Type	Naming Convention Format	Example
Single-Column Index	<table_name>_<column_name>_idx	digital_token_device_idx
Multi-Column Index	<table_name>_<column1>_<column2>_idx	digital_token_device_status_idx

Constraint Type	Naming Convention Format	Example
Primary Key	<table_name>_pkey	user_pkey
Foreign Key	<reference_table_name>_<reference_column_name>_fkey	card_user_fkey
Unique Key	<table_name>_<column_name>_key	user_email_key
Check Constraint	<table_name>_<column_name>_check	card_status_check

@Auditable
* log.error should pass in the error message and Throwable object to allow exception stacktrace printed out in logs.  

@ControllerAdvice

ExceptionHandling

ErrorResponse & ProblemDetails

Avoid constants as much as possible put it in lowest layer that use it directly

@Mapper & @MapperConfig



Git hooks - scope, branch names, ticket numbers

git sync <branch-name>
- Git checkout <branch-name>
- Git pull origin <branch-name>
- Git checkout -
- Git merge <branch-name>

git prune 

HTTPS only
Post with JSON Body for sensitive data

Use headers for auth tokens
Token management best practices
HTTP-Only secure cookies
Rate limiting + Logging + IP Filtering

Central Configuration (Audit Logging, IP Blacklisting/ whitelisitng)
CSRF, CORS, HTTPS, SSL, Session & Header Protection, Testing, HTTP Study, OWASP API Security

https://docs.spring.io/spring-data/commons/reference/api/java/org/springframework/data/domain/Pageable.html


—
Transaction
- Id, Transaction Id, Original Transaction Id, Transaction Date, MCA Debit Current, MCD Debit Amount, MCA Credit Current, MCA Credit Amount, Payment Current, Payment Amount, Billing current, Billing Amount, Payment Method

1:01p.m., 2:05:55



