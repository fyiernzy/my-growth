07082025

Sdadasdasd

Float/Double
- isGreaterThan (tolerance)
- isLessThan((tolerance)
- isGreaterThanOrEqual (tolerance)
- isLessThanOrEqual (tolerance)
- isEqual(tolerance)

6.99 - 7.0 ‎ = -0.01
6.999 - 7.0 ‎ = -0.001

6.999 - 7.0 0.01

6.


 3.1

3.1 - 3.000000005363 

0.001 > tol

6.9999 - 7.0
- [x] Add new methods
    - [x] Double
    - [x] double
    - [x] Float
    - [x] float
- [ ] Test cases
- [ ] MR & Checking

4:16:26
TL;DR
What it is	Where it comes from	What it points to	When it doesn’t help
CI_COMMIT_BEFORE_SHA	A GitLab-provided variable that’s already set in every branch or tag pipeline	The exact commit that was at the tip of the ref before the push that triggered this pipeline	Always 000000…000 for merge-request pipelines, the first commit on a new branch, scheduled pipelines, or manual runs(GitLab Docs)
git rev-parse HEAD~1	A Git command you run inside the job	The immediate parent of the current HEAD (i.e. one commit back, based only on the first-parent chain)(Stack Overflow)	Fails if the branch has only one commit (HEAD~1 doesn’t exist) and only gives you the last commit if several were pushed at once
Why they’re different in practice
1. Multiple commits in one push Push three commits and trigger a pipeline: A --- B --- C   ← remote branch *before* your push
2.                \
3.                 D --- E --- F   ← you push these three together
4. 
    * CI_COMMIT_BEFORE_SHA = C (the commit that was at the tip before the push)
    * HEAD~1 = E (the parent of the newest commit F)
5. If you diff CI_COMMIT_BEFORE_SHA..HEAD you get all three commits; with HEAD~1..HEAD you only see the last one (E ➜ F).
6. Merge-request (MR) pipelines In MR pipelines CI_COMMIT_BEFORE_SHA is always 000000…000 by design, because GitLab can’t know which ref you’ll merge into yet(GitLab Docs). For MRs you normally compare against $CI_MERGE_REQUEST_TARGET_BRANCH_SHA instead (as you do in your script).
7. First commit on a new branch
    * There is no parent commit, so HEAD~1 doesn’t exist.
    * CI_COMMIT_BEFORE_SHA is again 000000…000. You need a fallback (the Git “empty tree” object) for this edge case.
8. History rewrites / force-pushes CI_COMMIT_BEFORE_SHA records the old tip of the branch even after a force-push, so it can refer to a commit that no longer exists. HEAD~1 is immune to that because it looks strictly at the new history that’s been checked out.

Which one should you use?
* Branch pipelines with one commit per push – HEAD~1 is fine and slightly cheaper.
* Branch pipelines where people often push several commits at once – CI_COMMIT_BEFORE_SHA is safer because you won’t miss earlier commits in the same push.
* Merge-request pipelines – ignore both and diff against $CI_MERGE_REQUEST_TARGET_BRANCH_SHA.
* First-commit case – fall back to the empty-tree SHA (4b825dc…) so that every file is treated as “added”.
That hybrid logic is exactly what your pick_diff_base() helper implements: try MR → CI_COMMIT_BEFORE_SHA → HEAD~1 → empty tree, covering all scenarios while doing as little work as possible.



