06082025

AssertUtils
- [x] JMH Test Results * Ask for further enhancements
- [ ] Frontend/Util (Finished backend first)
- [x] AssertUtilsTest removes
- [x] Refinement based on chat history

Gradle
- [x] Split into two Gradle-files
- [x] Split into smaller tasks
- [x] Git commit -m “build: add separate gradle file into main build.gradlle”
- [x] Git commit -m “build: add executeCommand tasks into client.gradle”
- [x] Git commit -m “

Logging
- [ ] AuditTrail Solution planning


AssertUtil Notes
- Ns/op = nanosecond per operation, the averaged time measured in ns for each operation to perform
- Ops/s (thorughput) - number of operation performed per seconds
- Blackhole: Consume values
    - Why: To prevent Just-In-Time (JIT) compiler from optimising the benchmark code, ensuring methods executes fully, result is used in non-optimisable way, keep the benchmark remains accurate & honest
        - Without Blackhole
            - JVM may skip the code or lead to misleading results
        - With Blackhole
            - JVM is forced to run the code, so that results reflect actual performance.
- Number of tests (Cnt) = warmupIterations + measurementIterations × sub-iterations × repetitions
- @BenchmarkMode({Mode.Throughput, Mode.AverageTime})
    - Specifies the performance metric to measure
    - Available Modes: 
        - Throughput: Number of operations per seconds (ops/sec)
        - AverageTime: Average time per operation (ns/op)
        - SampleTime: Distributions of Execution Times (histogram)
        - SingleShotTime: Time for a single operation (no looping)
        - All Modes: All Above
- OutputTimeUnit: Set the output time units. Choices - NANOSECONDS, MILLISECONDS, MICROSECOND
- WarmUp - To allow JIT-compile and optimise code, to avoid initial run from not being representatives
- Measure measurements: Define how JMH Collect actual benchmark data after warmup
    - 10 measurement iterations
    - 500 ms per iteration
- Fork - how many separate VM should spawn
- @State: Defines the lifecycle of the benchmark. Options:
    - Thread: Each thread running the benchmark get its own instance of the class
    - Group: One instance per thread group (for concurrency tests)
    - Benchmark: One instance shared across all threads/forks
- @Setup - 
    - Level.Iteration, Level.Trial (Run before)
    - Level.Triall:
    - Level.Invocation: Before each individual benchmark call. 
- @Benchmark for the code that need to run benchmark tests

I think from my benchmark result, it shows that using Generic and Boxed overloaded values have no significant differences (since it's measured in nanoseconds and the gc.alloc is similar, the result is triviall and negligable), but why thrid library like ApacheCommon and Guave prefer overloaded methods over generic version?


Tilll 2:07p.m., 2:26:18

ext {
    executeCommands = { List<String> cmd, File workingDir = rootProject.projectDir ->
        try {
            logger.info("[exec] ${cmd.join(' ')} (cwd=${workingDir})")
            def proc = new ProcessBuilder(cmd)
                    .directory(workingDir)
                    .redirectErrorStream(true)
                    .start()
            proc.waitFor()
            proc.exitValue() == 0
                    ? proc.inputStream.text.trim()
                    : ""
        } catch (Exception e) {
            logger.warn("[exec] failure: ${e.message}")
            ""
        }
    }


    /**
     * Light wrapper for   git fetch <remote> <branch>
     */
    gitFetchBranch = { String remote = 'origin',
                       String branch,
                       File dir = rootProject.projectDir ->
        executeCommands(['git', 'fetch', '--no-tags', '--prune', remote, branch], dir)
    }

    gitDiffJava = { List<String> extraArgs = [],
                    File workingDir = rootProject.projectDir ->
        def cmd = ['git', 'diff',
                   '--name-only', '--diff-filter=ACMRTUXB'] +
                extraArgs +
                ['--', ':(glob)**/*.java']
        executeCommands(cmd, workingDir)
    }

    /**
     * Throw exception if no working directory is provided.
     * Might return empty string if no staged files found.
     */
    gitStagedJava = { File workingDirectory ->
        Objects.requireNonNull(workingDirectory, 'workingDirectory must not be null!')
        return gitDiffJava(['--cached'], workingDirectory);
    }

    /**
     * Throw exception if no working directory is provided.
     * Might return empty string if no unstaged files found.
     */
    gitUnstagedJava = { File workingDirectory ->
        Objects.requireNonNull(workingDirectory, 'workingDirectory must not be null!')
        return gitDiffJava([], workingDirectory)
    }

    getFilesFromProperty = { Project requester ->
        Objects.requireNonNull(requester, 'requester must not be null!')
        return requester.providers.gradleProperty('files').orElse('').get().trim();
    }

    fetchStagedJava = { Project requester ->
        // Priority 1: User manually provides files via -Pfiles
        def filesOverride = requester.providers.gradleProperty('files').orElse('').get().trim()

        if (filesOverride) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Using -Pfiles override")
            return filesOverride.replaceAll(/\s+/, '\n')
        }

        // Priority 2: GitLab CI/CD Merge Request context
        def env = System.getenv()
        def baseSha = env['CI_MERGE_REQUEST_TARGET_BRANCH_SHA']
        def headSha = env['CI_COMMIT_SHA']
        def defaultBranch = env['CI_DEFAULT_BRANCH'] ?: 'develop'

        if (baseSha && headSha) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] GitLab MR context detected: ${baseSha}..${headSha}")
            def output = gitDiffJava([baseSha, headSha], requester.projectDir)
            if (output) {
                requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${output.readLines().size()} Java file(s) in GitLab MR diff")
                return output
            }
        }

        // Priority 3: CI/CD Pipeline
        if (env['CI'] == 'true') {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] CI pipeline context – comparing against origin/${defaultBranch}")
            gitFetchBranch('origin', defaultBranch, project.projectDir)
            def output = gitDiffJava(["origin/${defaultBranch}", "HEAD"], requester.projectDir)
            if (output) {
                requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${output.readLines().size()} Java file(s) in CI diff against ${defaultBranch}")
                return output
            }
        }

        // Priority 4: Local development (interactive staging)
        def stagedFiles = gitDiffJava(['--cached'], requester.projectDir)

        if (stagedFiles) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${stagedFiles.readLines().size()} staged Java file(s)")
            return stagedFiles
        }

        // Priority 5: Local development - if no staged files, check unstaged changes
        def unstagedFiles = gitDiffJava([], requester.projectDir)

        if (unstagedFiles) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${unstagedFiles.readLines().size()} unstaged Java file(s)")
            return unstagedFiles
        }

        requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] No Java files found for checkstyle analysis")
        return ""
    }


    // In-memory cache and loader
    stagedJavaCache = null
    stagedJavaLock = new Object()

    /**
     * @param requester project calling the helper
     * @param useGlobalCache true → share Git diff for whole build
     */
    loadStagedJava = { Project requester, boolean useGlobalCache ->
        if (useGlobalCache) {
            synchronized (stagedJavaLock) {
                if (stagedJavaCache == null) {
                    stagedJavaCache = fetchStagedJava(requester)
                }
                return stagedJavaCache
            }
        }

        // Using module-local diff (no-caching)
        return fetchStagedJava(requester)
    }
}

Another file

import org.gradle.api.internal.provider.DefaultProvider
import com.ifastpay.GitUtils
import com.ifastpay.StagedFileUtils

plugins {
    id 'java'
    id 'org.springframework.boot' version "${springBootVersion}"
    id 'io.spring.dependency-management' version "${springDependencyVersion}"
    id 'org.owasp.dependencycheck' version "${owaspDependencyCheckVersion}"
    id 'checkstyle'
}

ext {
    executeCommands = { List<String> cmd, File workingDir = rootProject.projectDir ->
        try {
            logger.info("[exec] ${cmd.join(' ')} (cwd=${workingDir})")
            def proc = new ProcessBuilder(cmd)
                    .directory(workingDir)
                    .redirectErrorStream(true)
                    .start()
            proc.waitFor()
            proc.exitValue() == 0
                    ? proc.inputStream.text.trim()
                    : ""
        } catch (Exception e) {
            logger.warn("[exec] failure: ${e.message}")
            ""
        }
    }

    /**
     * Git diff that always returns Java files only (ACMRTUXB filter).
     * @param extraArgs list of additional args placed between
     *        '--diff-filter=ACMRTUXB' and the '--' separator
     *        e.g. ['--cached']  or  [baseSha, headSha]
     * @param dir working directory (defaults to repo root)
     */
    gitDiffJava = { List<String> extraArgs = [],
                    File workingDir = rootProject.projectDir ->
        def cmd = ['git', 'diff',
                   '--name-only', '--diff-filter=ACMRTUXB'] +
                extraArgs +
                ['--', ':(glob)**/*.java']
        executeCommands(cmd, workingDir)
    }

    /**
     * Light wrapper for   git fetch <remote> <branch>
     */
    gitFetchBranch = { String remote = 'origin',
                       String branch,
                       File dir = rootProject.projectDir ->
        executeCommands(['git', 'fetch', '--no-tags', '--prune', remote, branch], dir)
    }

    fetchStagedJava = { Project requester ->
        // Priority 1: User manually provides files via -Pfiles
        def filesOverride = requester.providers.gradleProperty('files').orElse('').get().trim()

        if (filesOverride) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Using -Pfiles override")
            return filesOverride.replaceAll(/\s+/, '\n')
        }

        // Priority 2: GitLab CI/CD Merge Request context
        def env = System.getenv()
        def baseSha = env['CI_MERGE_REQUEST_TARGET_BRANCH_SHA']
        def headSha = env['CI_COMMIT_SHA']
        def defaultBranch = env['CI_DEFAULT_BRANCH'] ?: 'develop'

        if (baseSha && headSha) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] GitLab MR context detected: ${baseSha}..${headSha}")
            def output = gitDiffJava([baseSha, headSha], requester.projectDir)
            if (output) {
                requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${output.readLines().size()} Java file(s) in GitLab MR diff")
                return output
            }
        }

        // Priority 3: CI/CD Pipeline
        if (env['CI'] == 'true') {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] CI pipeline context – comparing against origin/${defaultBranch}")
            gitFetchBranch('origin', defaultBranch, project.projectDir)
            def output = gitDiffJava(["origin/${defaultBranch}", "HEAD"], requester.projectDir)
            if (output) {
                requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${output.readLines().size()} Java file(s) in CI diff against ${defaultBranch}")
                return output
            }
        }

        // Priority 4: Local development (interactive staging)
        def stagedFiles = GitUtils.gitDiffJava(['--cached'], requester.projectDir)

        if (stagedFiles) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${stagedFiles.readLines().size()} staged Java file(s)")
            return stagedFiles
        }

        // Priority 5: Local development - if no staged files, check unstaged changes
        def unstagedFiles = gitDiffJava([], requester.projectDir)

        if (unstagedFiles) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${unstagedFiles.readLines().size()} unstaged Java file(s)")
            return unstagedFiles
        }

        requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] No Java files found for checkstyle analysis")
        return ""
    }


    // In-memory cache and loader
    stagedJavaCache = null
    stagedJavaLock = new Object()

    /**
     * @param requester project calling the helper
     * @param useGlobalCache true → share Git diff for whole build
     */
    loadStagedJava = { Project requester, boolean useGlobalCache ->
        if (useGlobalCache) {
            synchronized (stagedJavaLock) {
                if (stagedJavaCache == null) {
                    stagedJavaCache = fetchStagedJava(requester)
                }
                return stagedJavaCache
            }
        }

        // Using module-local diff (no-caching)
        return fetchStagedJava(requester)
    }
}

allprojects {
    group = 'com.ifast.ipaymy'
    version = '0.0.1-SNAPSHOT'

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    compileJava.options.encoding = 'UTF-8'

    if (!hasProperty('profile')) {
        ext.profile = 'local'
    }

    repositories {
        maven { url = 'https://plugins.gradle.org/m2/' }
        mavenCentral()
        maven {
            url = 'http://horizon.ifastfinancial.local:8003/nexus/content/groups/public'
            allowInsecureProtocol = true
        }
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'org.owasp.dependencycheck'
    apply plugin: 'checkstyle'
    apply from: "$rootDir/gradle/checkstyle-sub-project.gradle"

    dependencyManagement {
        imports {
            mavenBom "org.springframework.boot:spring-boot-dependencies:${springBootVersion}"
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudDependencyVersion}"
        }
    }

    dependencies {
        // Common Spring Boot Dependencies
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
//        implementation 'org.springframework.boot:spring-boot-starter-security'

        // Spring Cloud
        implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'

        // Lombok
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'

        // OpenAPI & Swagger
        implementation "io.swagger.core.v3:swagger-annotations:${swaggerAnnotationVersion}"
        implementation "org.openapitools:jackson-databind-nullable:${jacksonDatabindVersion}"
        implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiWebMvcUIVersion}"

        implementation 'jakarta.validation:jakarta.validation-api'

        // Testing
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'

        // Utility Libraries
        implementation 'org.apache.commons:commons-lang3'
        implementation "org.apache.commons:commons-collections4:${apacheCommonCollectionVersion}"

        implementation "org.apache.httpcomponents:httpclient:${apacheHttpClientVersion}"
    }

    tasks.named('test') {
        useJUnitPlatform()
    }

    // Global Checkstyle configuration
    checkstyle {
        toolVersion = '10.26.1'
        configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
        ignoreFailures = false
    }

    tasks.withType(Checkstyle).configureEach {
        reports {
            // Export to both xml and html files
            xml.setRequired(true)
            html.setRequired(true)

            // Group them by subproject > taskName
            // For instances,
            // - my-modular-ws/reports/checkstyle/checkstyleMain.html
            // - my-modular-ws/reports/checkstyle/checkstyleTest.html
            xml.outputLocation = layout.buildDirectory.file("reports/checkstyle/${name}.xml")
            html.outputLocation = layout.buildDirectory.file("reports/checkstyle/${name}.html")
        }
    }

    // Perform the Checkstyle on the leaf projects only
    if (childProjects.isEmpty()) {
//        tasks.register('checkstyleStaged', Checkstyle) {
//            group = 'verification'
//            description = "Run Checkstyle on only the staged Java files in ${path}"
//            classpath = files()
//
//            // 1. Import the extra property extensions
//            def exec = rootProject.extensions.extraProperties
//
//            // 2. Get the a list of Java files to be checked
//            // Since everything in the ext block is stored as/ returned as an Object
//            // We have to cast it explicitly using as Provider<String>
//            def stagedText = exec.has('globalGitDiff')
//                    ? exec.get('globalGitDiff') as Provider<String>
//                    : providers.provider { exec.loadStagedJava(project, false) } as Provider<String>
//
//            def candidateFiles = stagedText.map { txt ->
//                if (!txt?.trim()) return []
//
//                // This candidateFiles will keep only the staged Java files that reside within its own module
//                txt.readLines()
//                        .collect { it.trim() }
//                        .findAll { it.endsWith('.java') }
//                        .collect { rootProject.file(it) }
//                        .findAll { it.exists() }
//                        .findAll { it.toPath().startsWith(projectDir.toPath()) }
//            }
//
//            // 4. Wire the candidate list into the the Checkstyle
//            // Gradle now sees real inputs
//            def stagedJavaFiles = null;
//
//            def getStagedJavaFiles = {
//                if (stagedJavaFiles == null) {
//                    stagedJavaFiles = candidateFiles.get();
//                }
//                return stagedJavaFiles
//            }
//
//
//            inputs.files {
//                project.files(getStagedJavaFiles())
//            }
//
//            source {
//                project.files(getStagedJavaFiles())
//            }
//
//            outputs.upToDateWhen { false }
//
//            onlyIf {
//                def candidates = getStagedJavaFiles()
//                if (candidates.isEmpty()) {
//                    logger.lifecycle("[checkstyleStaged] [${project.path}] SKIPPED – No matching Java files in this module")
//                    return false
//                } else {
//                    logger.lifecycle("[checkstyleStaged] [${project.path}] Will run checkstyle on ${candidates.size()} file(s)")
//                    return true
//                }
//            }
//        }
    }
}

// Aggregate task at root to run all module-level 'checkstyleStaged'
//tasks.register('checkstyleStaged') {
//    group = 'verification'
//    description = 'Run Checkstyle on staged Java files across all modules'
//
//    def exec = rootProject.extensions.extraProperties;
//    exec.globalGitDiff = rootProject.providers.provider {
//        rootProject.extensions.extraProperties.loadStagedJava(rootProject, true)
//    } as DefaultProvider
//    exec.loadStagedJava(project, true)
//    dependsOn subprojects.collectMany { subproject ->
//        subproject.tasks.matching { it.name == 'checkstyleStaged' }
//    }
//}


2:32:19
apply plugin: 'checkstyle'
apply from: "$rootDir/gradle/git.gradle"


tasks.withType(Checkstyle).configureEach {
    reports {
        xml.required = true
        html.required = true
        xml.outputLocation = layout.buildDirectory.file("reports/checkstyle/${name}.xml")
        html.outputLocation = layout.buildDirectory.file("reports/checkstyle/${name}.html")
    }
}

def exec = project.extensions.extraProperties

def filesProviderFor = { Closure<String> supplier ->
    providers.provider {
        def raw = supplier.call() as String
        def text = raw == null ? "" : raw.toString()
        return text.readLines()
                .findAll { it.trim() }
                .collect { rootProject.file(it) }
                .findAll { it.exists() }
                .findAll { it.toPath().startsWith(project.projectDir.toPath()) }
                .asImmutable()
    }
}

def configureGitCheckstyle = { Checkstyle t, String desc, Provider<List<File>> diffText ->
    t.group = 'verification'
    t.description = desc
    t.configFile = rootProject.file('config/checkstyle/checkstyle.xml')
    t.classpath = files()

    List<File> memo = null
    def getFiles = {
        if (memo == null) {
            memo = diffText.get() as List<File>
        }
        memo
    }

    // real inputs for Gradle
    t.inputs.files { project.files(getFiles()) }
    t.source { project.files(getFiles()) }

    t.outputs.upToDateWhen { false }

    t.onlyIf {
        def files = getFiles()
        if (files.isEmpty()) {
            logger.lifecycle("[${t.name}] [${project.path}] SKIPPED – No matching Java files in this module")
            false
        } else {
            logger.lifecycle("[${t.name}] [${project.path}] Will run checkstyle on ${files.size()} file(s)")
            true
        }
    }
}

if (childProjects.isEmpty()) {
    tasks.register('checkstyleStaged', Checkstyle) { t ->
        def diffText = filesProviderFor { exec.loadStagedJava(project.projectDir, false) }
        configureGitCheckstyle(t, "Run Checkstyle on staged Java files in this ${project.path}.", diffText)
    }

// --- checkstyleUnstaged (worktree vs index)
    tasks.register('checkstyleUnstaged', Checkstyle) { t ->
        def diffText = filesProviderFor { exec.loadUnstagedJava(project.projectDir, false) }
        configureGitCheckstyle(t, 'Run Checkstyle on unstaged Java files in this module.', diffText)
    }

// --- checkstyleCommittedBetween (olderRef..newerRef; overridable via -PolderRef / -PnewerRef)
    tasks.register('checkstyleCommittedBetween', Checkstyle) { t ->
        def diffText = filesProviderFor {
            def older = providers.gradleProperty('olderRef').orElse('HEAD~1').get()
            def newer = providers.gradleProperty('newerRef').orElse('HEAD').get()
            exec.loadCommittedJava(older, newer, project.projectDir, false)
        }
        configureGitCheckstyle(t, 'Run Checkstyle on Java files changed between two refs (olderRef..newerRef).', diffText)
    }

// --- checkstyleLastCommitted (HEAD~1..HEAD)
    tasks.register('checkstyleLastCommitted', Checkstyle) { t ->
        def diffText = filesProviderFor { exec.loadLastCommittedJava(project.projectDir, false) }
        configureGitCheckstyle(t, 'Run Checkstyle on Java files from the last commit in this module (HEAD~1..HEAD).', diffText)
    }

// --- wire into `check`
    tasks.named('check') {
        dependsOn 'checkstyleStaged', 'checkstyleUnstaged', 'checkstyleCommittedBetween', 'checkstyleLastCommitted'
    }
}


plugins {
    id 'java'
    id 'org.springframework.boot' version "${springBootVersion}"
    id 'io.spring.dependency-management' version "${springDependencyVersion}"
    id 'org.owasp.dependencycheck' version "${owaspDependencyCheckVersion}"
    id 'checkstyle'
}

allprojects {
    group = 'com.ifast.ipaymy'
    version = '0.0.1-SNAPSHOT'

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    compileJava.options.encoding = 'UTF-8'

    if (!hasProperty('profile')) {
        ext.profile = 'local'
    }

    repositories {
        maven { url = 'https://plugins.gradle.org/m2/' }
        mavenCentral()
        maven {
            url = 'http://horizon.ifastfinancial.local:8003/nexus/content/groups/public'
            allowInsecureProtocol = true
        }
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'org.owasp.dependencycheck'
    apply plugin: 'checkstyle'
    apply from: "$rootDir/gradle/checkstyle-tasks.gradle"

    dependencyManagement {
        imports {
            mavenBom "org.springframework.boot:spring-boot-dependencies:${springBootVersion}"
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudDependencyVersion}"
        }
    }

    dependencies {
        // Common Spring Boot Dependencies
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
//        implementation 'org.springframework.boot:spring-boot-starter-security'

        // Spring Cloud
        implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'

        // Lombok
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'

        // OpenAPI & Swagger
        implementation "io.swagger.core.v3:swagger-annotations:${swaggerAnnotationVersion}"
        implementation "org.openapitools:jackson-databind-nullable:${jacksonDatabindVersion}"
        implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiWebMvcUIVersion}"

        implementation 'jakarta.validation:jakarta.validation-api'

        // Testing
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'

        // Utility Libraries
        implementation 'org.apache.commons:commons-lang3'
        implementation "org.apache.commons:commons-collections4:${apacheCommonCollectionVersion}"

        implementation "org.apache.httpcomponents:httpclient:${apacheHttpClientVersion}"
    }

    tasks.named('test') {
        useJUnitPlatform()
    }

    // Global Checkstyle configuration
    checkstyle {
        toolVersion = '10.26.1'
        configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
        ignoreFailures = false
    }
}



import java.util.concurrent.ConcurrentHashMap

ext {
    executeCommands = { List<String> cmd, File workingDir = rootProject.projectDir ->
        try {
            logger.info("[exec] ${cmd.join(' ')} (cwd=${workingDir})")
            def proc = new ProcessBuilder(cmd)
                    .directory(workingDir)
                    .redirectErrorStream(true)
                    .start()
            proc.waitFor()
            return proc.exitValue() == 0
                    ? proc.inputStream.text.trim()
                    : ""
        } catch (Exception e) {
            logger.warn("[exec] failure: ${e.message}")
            return ""
        }
    }

    executeExitCode = { List<String> cmd, File workingDir ->
        try {
            def p = new ProcessBuilder(cmd)
                    .directory(workingDir)
                    .redirectErrorStream(true)
                    .start()
            p.waitFor()
            return p.exitValue()
        } catch (Exception e) {
            logger.warn("[exec:code] failure: ${e.message}")
            return 2
        }
    }

    gitIsAncestor = { String a, String b, File dir ->
        executeExitCode(['git', 'merge-base', '--is-ancestor', a, b], dir) == 0
    }

    /**
     * Throw exception if no working directory is provided.
     * Might return empty string if no different files found.
     */
    gitDiffJava = { List<String> extraArgs = [],
                    File workingDir = rootProject.projectDir ->
        Objects.requireNonNull(workingDir)
        def cmd = ['git', 'diff',
                   '--name-only', '--diff-filter=ACMRTUXB'] +
                extraArgs +
                ['--', ':(top,glob)**/*.java']
        executeCommands(cmd, workingDir)
    }

    /**
     * Throw exception if no working directory is provided.
     * Might return empty string if no staged files found.
     */
    gitStagedJava = { File workingDir = rootProject.projectDir ->
        return gitDiffJava(['--cached'], workingDir)
    }

    /**
     * Throw exception if no working directory is provided.
     * Might return empty string if no unstaged files found.
     */
    gitUnstagedJava = { File workingDir = rootProject.projectDir ->
        return gitDiffJava([], workingDir)
    }

    /**
     * Java files changed between two commits/refs (older -> newer).
     * Defaults to previous commit vs current HEAD.
     *
     * Example:
     *   gitCommittedJava('HEAD~1', 'HEAD', project.projectDir)
     *   gitCommittedJava('origin/main', 'HEAD', project.projectDir)
     */
    gitCommittedJava = { String olderRef = 'HEAD~1',
                         String newerRef = 'HEAD',
                         File workingDir = rootProject.projectDir ->

        // 1. Check if the ref format is valid
        def isValidNewerRefFormat = { String r -> r == 'HEAD' || (r ==~ /HEAD~\d+/) }
        def isValidOlderRefFormat = { String r -> r ==~ /HEAD~[1-9]\d*/ }

        if (!isValidOlderRefFormat(olderRef)) {
            throw new GradleException("Invalid olderRef '${olderRef}'. Use 'HEAD~<positive integer>', e.g. 'HEAD~1'.")
        }
        if (!isValidNewerRefFormat(newerRef)) {
            throw new GradleException("Invalid newerRef '${newerRef}'. Use 'HEAD' or 'HEAD~<integer>'.")
        }
        if (olderRef == newerRef) {
            throw new GradleException("olderRef and newerRef must differ (got '${olderRef}').")
        }

        // 2. Check if the ordering is valid
        if (!gitIsAncestor(olderRef, newerRef, workingDir)) {
            if (gitIsAncestor(newerRef, olderRef, workingDir)) {
                // olderRef comes *after* newerRef → fail as requested
                throw new GradleException("Invalid range: '${olderRef}' is newer than '${newerRef}'.")
            } else {
                // neither is ancestor of the other (e.g., different branches)
                throw new GradleException("Refs are unrelated: '${olderRef}' is not an ancestor of '${newerRef}'.")
            }
        }

        return gitDiffJava(['-M', olderRef, newerRef], workingDir)
    }

    gitLastCommittedJava = { File workingDir = rootProject.projectDir ->
        return gitCommittedJava('HEAD~1', 'HEAD', workingDir)
    }

    getFilesFromProperty = { Project requester ->
        Objects.requireNonNull(requester, 'requester must not be null!')
        return requester.providers.gradleProperty('files').orElse('').get().trim();
    }

    fetchStagedJava = { Project requester ->
        def filesOverride = getFilesFromProperty(requester)

        if (filesOverride) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Using -Pfiles override")
            return filesOverride.replaceAll(/\s+/, '\n')
        }

        def stagedFiles = gitDiffJava(['--cached'], requester.projectDir)

        if (stagedFiles) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${stagedFiles.readLines().size()} staged Java file(s)")
            return stagedFiles
        }

        def unstagedFiles = gitDiffJava([], requester.projectDir)

        if (unstagedFiles) {
            requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] Found ${unstagedFiles.readLines().size()} unstaged Java file(s)")
            return unstagedFiles
        }

        requester.logger.lifecycle("[checkstyleStaged] [${requester.path}] No Java files found for checkstyle analysis")
        return ""
    }

    def ext = project.extensions.extraProperties

    if (!ext.has('_gitCache')) {
        ext._gitCache = [
                staged       : new ConcurrentHashMap<String, Object>(),
                unstaged     : new ConcurrentHashMap<String, Object>(),
                committed    : new ConcurrentHashMap<String, Object>(),
                lastCommitted: new ConcurrentHashMap<String, Object>(),
                filesProp    : new ConcurrentHashMap<String, Object>(),
        ]
    }

    def memoize = { String region, String key, boolean global, Closure supplier ->
        if (!global) {
            return supplier.call()
        }
        def m = ext._gitCache[region] as ConcurrentHashMap<String, Object>
        return m.computeIfAbsent(key) { supplier.call() }
    }

    loadStagedJava = { File dir = rootProject.projectDir, boolean global = false ->
        def key = dir.absoluteFile.path
        return memoize('staged', key, global) { gitStagedJava(dir) }
    }

    loadUnstagedJava = { File dir = rootProject.projectDir, boolean global = false ->
        def key = dir.absoluteFile.path
        return memoize('unstaged', key, global) { gitUnstagedJava(dir) }
    }

    loadCommittedJava = { String olderRef = 'HEAD~1', String newerRef = 'HEAD',
                              File dir = rootProject.projectDir, boolean global = false ->
        def key = "${olderRef}|${newerRef}|${dir.absoluteFile.path}"
        return memoize('committed', key, global) { gitCommittedJava(olderRef, newerRef, dir) }
    }

    loadLastCommittedJava = { File dir = rootProject.projectDir, boolean global = false ->
        def key = dir.absoluteFile.path
        return memoize('lastCommitted', key, global) { gitLastCommittedJava(dir) }
    }

    loadFilesFromProperty = { Project p, boolean global = false ->
        Objects.requireNonNull(p, 'requester must not be null!')
        def key = p.path
        return memoize('filesProp', key, global) { getFilesFromProperty(p) }
    }

    clearGitCache = {
        (ext._gitCache as Map).values().each { (it as Map).clear() }
    }
}




package com.ifastpay

import org.gradle.api.Project

class GitUtils {

    private GitUtils() {
    }

    static String executeCommand(List<String> cmd, Project requester) {
        def workingDir = requester.projectDir
        def logger = requester.logger

        try {
            logger.info("[exec] ${cmd.join(' ')} (cwd=${workingDir})")
            def proc = new ProcessBuilder(cmd)
                    .directory(workingDir)
                    .redirectErrorStream(true)
                    .start()
            proc.waitFor()
            return proc.exitValue() == 0 ? proc.inputStream.text.trim() : ""
        } catch (Exception e) {
            logger.warn("[exec] failure: ${e.message}")
            return ""
        }
    }

    static String gitDiffJava(List<String> extraArgs = [], Project requester) {
        def cmd = ['git', 'diff', '--name-only', '--diff-filter=ACMRTUXB'] +
                extraArgs +
                ['--', ':(glob)**/*.java']
        return executeCommand(cmd, requester)
    }

    static void gitFetchBranch(String remote = 'origin', String branch, Project requester) {
        executeCommand(['git', 'fetch', '--no-tags', '--prune', remote, branch], requester)
    }
}


package com.ifastpay

import org.gradle.api.Project

class StagedFileUtils {

    private StagedFileUtils() {
    }

    static String detectStagedJavaFiles(Project project) {
        def logger = project.logger

        // Priority 1: User manually provides files via -Pfiles
        def filesOverride = project.providers.gradleProperty('files').orElse('').get().trim()
        if (filesOverride) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] Using -Pfiles override")
            return filesOverride.replaceAll(/\s+/, '\n')
        }

        // Priority 2: GitLab CI/CD Merge Request context
        def env = System.getenv()
        def baseSha = env['CI_MERGE_REQUEST_TARGET_BRANCH_SHA']
        def headSha = env['CI_COMMIT_SHA']
        def defaultBranch = env['CI_DEFAULT_BRANCH'] ?: 'develop'

        if (baseSha && headSha) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] GitLab MR context detected: ${baseSha}..${headSha}")
            def output = GitUtils.gitDiffJava([baseSha, headSha], project)
            if (output) {
                logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${output.readLines().size()} Java file(s) in GitLab MR diff")
                return output
            }
        }

        // Priority 3: CI/CD Pipeline
        if (env['CI'] == 'true') {
            logger.lifecycle("[checkstyleStaged] [${project.path}] CI pipeline context – comparing against origin/${defaultBranch}")
            GitUtils.gitFetchBranch('origin', defaultBranch, project)
            def output = GitUtils.gitDiffJava(["origin/${defaultBranch}", "HEAD"], project)
            if (output) {
                logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${output.readLines().size()} Java file(s) in CI diff against ${defaultBranch}")
                return output
            }
        }

        // Priority 4: Local development (interactive staging)
        def stagedFiles = GitUtils.gitDiffJava(['--cached'], project)
        if (stagedFiles) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${stagedFiles.readLines().size()} staged Java file(s)")
            return stagedFiles
        }

        // Priority 5: Local development - if no staged files, check unstaged changes
        def unstagedFiles = GitUtils.gitDiffJava([], project)
        if (unstagedFiles) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${unstagedFiles.readLines().size()} unstaged Java file(s)")
            return unstagedFiles
        }

        logger.lifecycle("[checkstyleStaged] [${project.path}] No Java files found for checkstyle analysis")
        return ""
    }
}


plugins {
    id 'groovy'              // gives you compileGroovy etc.
}

repositories {
    mavenCentral()           // where Groovy lives
    gradlePluginPortal()     // optional, if you pull Gradle plugins
}

dependencies {
    implementation gradleApi()   // Gradle types for your helpers
    implementation localGroovy() // Groovy that ships with your Gradle
}













