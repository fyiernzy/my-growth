15082025

AuditTrail Changes
Open-api-properties
Audit-trail-admin
Audit-trail-client

- [ ] Fix trace id issue

- [ ] DetailModel - add new traceId (& criteria)
- [ ] Bean & Pk (Both) new 
- [ ] AuditTrailConstant, AudittrailReportFormat
- [ ] Mapper
- [ ] Query (Dynamic Searching)
- [ ] TraceUtils for getting current trace id
- [ ] SQL Schema

ApiLog Changes
- [ ] Entity & script
- [ ] RequestModel
- [ ] LogApiAspect
- [ ] ApiLogConstant
- [ ] ApiLogMapper
- [ ] SQL Schema


How to test
- ApiLog Use @LogApi(isEnabled=true) and connect to remote DB & run command (table=API_LOG_REQUEST, db in application.yml
- AuditTrail a bit tricky, can refer to FxOrderServiceImpl, basically need to have both annotations & method arguments & setContext to fit into the template defined in the Enum

BeanPost (Spring)‚Ä®OpenTelemetry



In your example, AuditTrailClientBean and AuditTrailClientPk serve very different roles in JPA, even though they‚Äôre closely related. Let‚Äôs break it down:

1Ô∏è‚É£ Differences between Bean and Pk
Aspect	AuditTrailClientBean	AuditTrailClientPk
Purpose	Represents the entity/table in the database.	Represents the composite primary key of the entity.
Annotation	@Entity ‚Äì JPA will map this to a table (AUDIT_TRAIL_CLIENT).	@Embeddable ‚Äì JPA will embed this class inside an entity to represent its ID.
Relationship	Has a field @EmbeddedId auditTrailClientPk that holds the key values.	Contains the individual key fields (module, action, userId, etc.).
Lifecycle Hooks	Can have lifecycle methods like @PrePersist to handle logic before saving (e.g., setting createdDate).	Usually doesn‚Äôt contain lifecycle hooks ‚Äî it‚Äôs just a key definition.
Persistence Mapping	Maps table-level metadata (@Table, auditing, etc.).	Maps columns that make up the PK (@Column, constraints).
Serializable	Doesn‚Äôt have to be Serializable.	Must implement Serializable (JPA requirement for composite keys).
Business Data	May contain non-PK columns too. In your example, all data is actually part of the PK, but in other designs, non-key fields exist here.	Contains only PK fields.
Usage in Queries	Queried as an entity (entityManager.find(AuditTrailClientBean.class, pk)).	Used as a key object (new AuditTrailClientPk(...) passed to find).
2Ô∏è‚É£ Why design this way?
You‚Äôve implemented a Composite Primary Key design in JPA.
üîπ Why use a composite PK here?
* Your table‚Äôs uniqueness is determined by a combination of fields:
    * module
    * action
    * userId
    * createdDate
    * serverIp
    * userIp
    * versionInfo
* There‚Äôs no single id column that uniquely identifies a row.
* Instead of putting all those fields directly in the entity class, JPA lets you group them in an @Embeddable key class for cleaner separation.

üîπ Benefits of separating PK into @Embeddable:
1. Cleaner code & separation of concerns
    * AuditTrailClientPk only cares about identity.
    * AuditTrailClientBean cares about the entity as a whole.
2. Reusability
    * If you have another entity that shares the same composite key structure, you can reuse AuditTrailClientPk.
3. Encapsulation for composite keys
    * JPA requires composite keys to be either:
        * Annotated with @IdClass
        * Or embedded via @EmbeddedId (your approach)
    * @EmbeddedId allows the PK to be a value object, improving encapsulation.
4. Logical grouping
    * All PK-related constants, column mappings, and equality logic (equals, hashCode) are together in one place.

üîπ Why not just put all fields in AuditTrailClientBean?
* You could, but then you‚Äôd need to:
    * Add multiple @Id annotations directly on the entity.
    * Implement equals & hashCode in the entity.
    * Clutter your entity with PK-specific code.
* Using @EmbeddedId keeps the entity more focused and more readable.

3Ô∏è‚É£ How it works in practice
Example usage:
AuditTrailClientPk pk = new AuditTrailClientPk();
pk.setModule("HR");
pk.setAction("CREATE");
pk.setUserId("john");
pk.setServerIp("192.168.0.1");
pk.setUserIp("10.0.0.5");
pk.setVersionInfo("v1");
pk.setCreatedDate(OffsetDateTime.now());

AuditTrailClientBean bean = new AuditTrailClientBean();
bean.setAuditTrailClientPk(pk);

entityManager.persist(bean);
Here:
* pk contains all identity-defining fields.
* bean is the actual entity object persisted to the DB.

‚úÖ In short:
* Bean = the entity (represents the table).
* Pk = the composite key (represents the identity).
* This design is needed because the table has a composite primary key rather than a single id. Using @EmbeddedId is the cleaner, more object-oriented way to handle it.

If you want, I can also explain why JPA requires Serializable and equals/hashCode in the PK ‚Äî that‚Äôs a subtle but important part of this design. Would you like me to go into that?
