
Project Management; single requirement, large requirement, etc.

Requirement by modules
Function by modules


Till 11:16a.m., 1:19:02
- 重新组织了内容，并思考了要做什么，并和 Wei Li 尝试确定内容

Till 1:16p.m., 1:22:18
- 研讨了 Decorator(Mutator) /Utils/Builder 的思考
- 完成了 Authentication/Section 2.2，并学习了 getBaseClientId 的作用与其上下文，比如AuthenticationUtil, OauthRestTemplateServiceImpl, ClientDetailsHelperService 等

Starting at 1:24p.m.,  Objective: 
- 了解 getAccessToken 的相关机制，验证是否有其他需要配置的内容来完成 refreshToken
- 验证当前登录 & 验证 (2FA, Authentication)；验证 “只要持有 Token，任何人都可以通过 FSMOne 的应用程序进入某用户的 iFastPay”
- 学习成果
- Till 2:30p.m., 54:44
    - 通读了一遍 getAccessToken 的路径和请求全过程，排查了验证条件和需要二次验证的内容。目前除了 SecurityContextHolder.getContext() 这部分需要专研之外基本能够确定配置了 BaseRestTemplate 和 client-id 之后就没问题了。
- Start: 2:39p.m., End: 3:44p.m., 52:17
    - 尝试找到 OAuth2 的 SecurityContextHolder 在哪里配置，但一无所获。重新复习了 my-oauth2-ws 的代码，且加深了 Spring Security 6/ Spring Authorization Server 的理解和对 OAuth2 的处理方式

学习如何阅读 Code using IntelliJ

* DefaultSecurityContextAccessor

authorizationServerEndpointsConfiguration.getEndpointsConfigurer()
    .getTokenGranter()
    .grant(tokenRequest.getGrantType(), tokenRequest);

The client does not have to set anything into the SecurityContextHolder explicitly.

Here’s how it works in the legacy Spring Security OAuth2 Authorization Server flow:
* When a client (internal service, front-end, etc.) calls your /oauth/token endpoint with the right credentials (usually client_id/client_secret in HTTP Basic or form parameters),
* Spring Security’s token endpoint filter intercepts that request,
* It uses your configured ClientDetailsService (your JdbcClientDetailsService with CustomPasswordEncoder) to verify the client credentials,
* If valid, Spring creates a client Authentication and automatically puts it into SecurityContextHolder for that request,
* Then your configured TokenGranter chain is invoked to issue the access/refresh tokens.
👉 From the client’s perspective, the only thing it has to do is send the request with the proper credentials (Basic auth or form-based). The whole process of validating the client, creating the Authentication, and setting it in the SecurityContextHolder is handled entirely by the auth server’s security configuration and filters in the background.

Here’s a concrete example of how an OAuth2 client would call your /oauth/token endpoint. The client doesn’t manage SecurityContextHolder at all — Spring Security does that on the auth server side when this request arrives.

Example: Password grant
POST /oauth/token HTTP/1.1
Host: auth-server.example.com
Authorization: Basic bXlDbGllbnRJZDpteUNsaWVudFNlY3JldA==   # clientId:clientSecret base64
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=john.doe&password=123456
* Authorization: Basic … → this is where the client authenticates itself.
* grant_type=password → tells the server we’re doing the password grant.
* username + password → the resource owner’s credentials.
* On the server side, the client credentials are verified first → if valid, Spring Security sets the client’s Authentication into SecurityContextHolder.
* Then the TokenGranter handles the user part.

Example: Client credentials grant
POST /oauth/token HTTP/1.1
Host: auth-server.example.com
Authorization: Basic bXlDbGllbnRJZDpteUNsaWVudFNlY3JldA==   # clientId:clientSecret base64
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&scope=read
* Only the client itself is authenticated here (no user).
* On the server side, the client authentication filter validates the header and sets a client-only Authentication in SecurityContextHolder.

Example: Refresh token grant
POST /oauth/token HTTP/1.1
Host: auth-server.example.com
Authorization: Basic bXlDbGllbnRJZDpteUNsaWVudFNlY3JldA==   # clientId:clientSecret base64
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=xyz123
* The refresh token is presented, but the client must still authenticate.
* Again, Spring’s filter sets the client into the SecurityContextHolder before the refresh token is validated.

✅ So the client just sends a normal HTTP request with the proper headers and form parameters. On the auth server side, Spring Security automatically:
1. Extracts client credentials,
2. Verifies them against your JdbcClientDetailsService + password encoder,
3. If valid, puts a ClientAuthentication into SecurityContextHolder,
4. Hands over to your TokenGranter chain to actually mint the token.
Would you like me to also sketch out what the JSON response looks like for each of these grant types (access token + refresh token fields)? That might be useful in your report.

Exactly 👍 — that’s one of the key things that makes the Resource Owner Password Credentials grant special.
Flow recap
1. Client sends request to /oauth/token: POST /oauth/token
2. Authorization: Basic base64(clientId:clientSecret)
3. Content-Type: application/x-www-form-urlencoded
4. 
5. grant_type=password&username=john&password=123456
6. 
    * The HTTP Basic header authenticates the client.
    * The form parameters authenticate the resource owner (user).
7. On the auth server:
    * Spring’s token endpoint filter authenticates the client and puts a client Authentication into the SecurityContextHolder.
    * Then the ResourceOwnerPasswordTokenGranter uses your configured AuthenticationManager to validate the user credentials.
8. Resulting OAuth2Authentication:
    * The top-level object is an OAuth2Authentication.
    * It contains two parts:
        * An OAuth2Request (client information — clientId, scopes, authorities allowed).
        * A user Authentication (e.g. a UsernamePasswordAuthenticationToken representing the logged-in user).
So yes ✅ — the final OAuth2Authentication object represents a union of both:
* Client credentials (who is the caller / app).
* User credentials (who is the resource owner).
This is different from the client_credentials grant, where the OAuth2Authentication has only the client authentication and no user authentication (user auth is null).

Do you want me to sketch a sample JSON-serialized view of an OAuth2Authentication after a password grant, so you can see clearly how both client and user info are stored?


—
So the UsernamePasswordAuthenticationFilter is only invoked when the SecurityContext is not set?

No. UsernamePasswordAuthenticationFilter is in the chain for every request, but it only does work when the request matches its loginProcessingUrl (and HTTP method, usually POST). It does not check whether SecurityContext is already set.
Quick breakdown:
* Invocation: The filter’s doFilter runs on every request.
* When it attempts auth: Only if requestMatcher.matches(request) → typically your /rest/login POST.
* SecurityContext check: None by default. If the request is the login URL, it will still attempt authentication even if SecurityContext already has an Authentication.
* Contrast with token filters: Filters like BearerTokenAuthenticationFilter usually skip if SecurityContext already contains an authenticated principal.
Practical tip for your setup:
* Make sure your custom token filter skips /rest/login, and let UsernamePasswordAuthenticationFilter handle just the login endpoint. This avoids redundant or conflicting authentication logic on the same request.

Decorator (Facade).of -> SpecificDecorator

Delegator.of().SpecificDelegator

Builder vs Decorator/Delegator
