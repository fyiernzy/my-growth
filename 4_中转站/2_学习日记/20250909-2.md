
Project Management; single requirement, large requirement, etc.

Requirement by modules
Function by modules


Till 11:16a.m., 1:19:02
- é‡æ–°ç»„ç»‡äº†å†…å®¹ï¼Œå¹¶æ€è€ƒäº†è¦åšä»€ä¹ˆï¼Œå¹¶å’Œ Wei Li å°è¯•ç¡®å®šå†…å®¹

Till 1:16p.m., 1:22:18
- ç ”è®¨äº† Decorator(Mutator) /Utils/Builder çš„æ€è€ƒ
- å®Œæˆäº† Authentication/Section 2.2ï¼Œå¹¶å­¦ä¹ äº† getBaseClientId çš„ä½œç”¨ä¸Žå…¶ä¸Šä¸‹æ–‡ï¼Œæ¯”å¦‚AuthenticationUtil, OauthRestTemplateServiceImpl, ClientDetailsHelperService ç­‰

Starting at 1:24p.m.,  Objective: 
- äº†è§£ getAccessToken çš„ç›¸å…³æœºåˆ¶ï¼ŒéªŒè¯æ˜¯å¦æœ‰å…¶ä»–éœ€è¦é…ç½®çš„å†…å®¹æ¥å®Œæˆ refreshToken
- éªŒè¯å½“å‰ç™»å½• & éªŒè¯ (2FA, Authentication)ï¼›éªŒè¯ â€œåªè¦æŒæœ‰ Tokenï¼Œä»»ä½•äººéƒ½å¯ä»¥é€šè¿‡ FSMOne çš„åº”ç”¨ç¨‹åºè¿›å…¥æŸç”¨æˆ·çš„ iFastPayâ€
- å­¦ä¹ æˆæžœ
- Till 2:30p.m., 54:44
    - é€šè¯»äº†ä¸€é getAccessToken çš„è·¯å¾„å’Œè¯·æ±‚å…¨è¿‡ç¨‹ï¼ŒæŽ’æŸ¥äº†éªŒè¯æ¡ä»¶å’Œéœ€è¦äºŒæ¬¡éªŒè¯çš„å†…å®¹ã€‚ç›®å‰é™¤äº† SecurityContextHolder.getContext() è¿™éƒ¨åˆ†éœ€è¦ä¸“ç ”ä¹‹å¤–åŸºæœ¬èƒ½å¤Ÿç¡®å®šé…ç½®äº† BaseRestTemplate å’Œ client-id ä¹‹åŽå°±æ²¡é—®é¢˜äº†ã€‚
- Start: 2:39p.m., End: 3:44p.m., 52:17
    - å°è¯•æ‰¾åˆ° OAuth2 çš„ SecurityContextHolder åœ¨å“ªé‡Œé…ç½®ï¼Œä½†ä¸€æ— æ‰€èŽ·ã€‚é‡æ–°å¤ä¹ äº† my-oauth2-ws çš„ä»£ç ï¼Œä¸”åŠ æ·±äº† Spring Security 6/ Spring Authorization Server çš„ç†è§£å’Œå¯¹ OAuth2 çš„å¤„ç†æ–¹å¼

å­¦ä¹ å¦‚ä½•é˜…è¯» Code using IntelliJ

* DefaultSecurityContextAccessor

authorizationServerEndpointsConfiguration.getEndpointsConfigurer()
    .getTokenGranter()
    .grant(tokenRequest.getGrantType(), tokenRequest);

The client does not have to set anything into the SecurityContextHolder explicitly.

Hereâ€™s how it works in the legacy Spring Security OAuth2 Authorization Server flow:
* When a client (internal service, front-end, etc.) calls your /oauth/token endpoint with the right credentials (usually client_id/client_secret in HTTP Basic or form parameters),
* Spring Securityâ€™s token endpoint filter intercepts that request,
* It uses your configured ClientDetailsService (your JdbcClientDetailsService with CustomPasswordEncoder) to verify the client credentials,
* If valid, Spring creates a client Authentication and automatically puts it into SecurityContextHolder for that request,
* Then your configured TokenGranter chain is invoked to issue the access/refresh tokens.
ðŸ‘‰ From the clientâ€™s perspective, the only thing it has to do is send the request with the proper credentials (Basic auth or form-based). The whole process of validating the client, creating the Authentication, and setting it in the SecurityContextHolder is handled entirely by the auth serverâ€™s security configuration and filters in the background.

Hereâ€™s a concrete example of how an OAuth2 client would call your /oauth/token endpoint. The client doesnâ€™t manage SecurityContextHolder at all â€” Spring Security does that on the auth server side when this request arrives.

Example: Password grant
POST /oauth/token HTTP/1.1
Host: auth-server.example.com
Authorization: Basic bXlDbGllbnRJZDpteUNsaWVudFNlY3JldA==   # clientId:clientSecret base64
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=john.doe&password=123456
* Authorization: Basic â€¦ â†’ this is where the client authenticates itself.
* grant_type=password â†’ tells the server weâ€™re doing the password grant.
* username + password â†’ the resource ownerâ€™s credentials.
* On the server side, the client credentials are verified first â†’ if valid, Spring Security sets the clientâ€™s Authentication into SecurityContextHolder.
* Then the TokenGranter handles the user part.

Example: Client credentials grant
POST /oauth/token HTTP/1.1
Host: auth-server.example.com
Authorization: Basic bXlDbGllbnRJZDpteUNsaWVudFNlY3JldA==   # clientId:clientSecret base64
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&scope=read
* Only the client itself is authenticated here (no user).
* On the server side, the client authentication filter validates the header and sets a client-only Authentication in SecurityContextHolder.

Example: Refresh token grant
POST /oauth/token HTTP/1.1
Host: auth-server.example.com
Authorization: Basic bXlDbGllbnRJZDpteUNsaWVudFNlY3JldA==   # clientId:clientSecret base64
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=xyz123
* The refresh token is presented, but the client must still authenticate.
* Again, Springâ€™s filter sets the client into the SecurityContextHolder before the refresh token is validated.

âœ… So the client just sends a normal HTTP request with the proper headers and form parameters.â€¨On the auth server side, Spring Security automatically:
1. Extracts client credentials,
2. Verifies them against your JdbcClientDetailsService + password encoder,
3. If valid, puts a ClientAuthentication into SecurityContextHolder,
4. Hands over to your TokenGranter chain to actually mint the token.
Would you like me to also sketch out what the JSON response looks like for each of these grant types (access token + refresh token fields)? That might be useful in your report.

Exactly ðŸ‘ â€” thatâ€™s one of the key things that makes the Resource Owner Password Credentials grant special.
Flow recap
1. Client sends request to /oauth/token:â€¨POST /oauth/token
2. Authorization: Basic base64(clientId:clientSecret)
3. Content-Type: application/x-www-form-urlencoded
4. 
5. grant_type=password&username=john&password=123456
6. 
    * The HTTP Basic header authenticates the client.
    * The form parameters authenticate the resource owner (user).
7. On the auth server:
    * Springâ€™s token endpoint filter authenticates the client and puts a client Authentication into the SecurityContextHolder.
    * Then the ResourceOwnerPasswordTokenGranter uses your configured AuthenticationManager to validate the user credentials.
8. Resulting OAuth2Authentication:
    * The top-level object is an OAuth2Authentication.
    * It contains two parts:
        * An OAuth2Request (client information â€” clientId, scopes, authorities allowed).
        * A user Authentication (e.g. a UsernamePasswordAuthenticationToken representing the logged-in user).
So yes âœ… â€” the final OAuth2Authentication object represents a union of both:
* Client credentials (who is the caller / app).
* User credentials (who is the resource owner).
This is different from the client_credentials grant, where the OAuth2Authentication has only the client authentication and no user authentication (user auth is null).

Do you want me to sketch a sample JSON-serialized view of an OAuth2Authentication after a password grant, so you can see clearly how both client and user info are stored?


â€”
So the UsernamePasswordAuthenticationFilter is only invoked when the SecurityContext is not set?

No. UsernamePasswordAuthenticationFilter is in the chain for every request, but it only does work when the request matches its loginProcessingUrl (and HTTP method, usually POST). It does not check whether SecurityContext is already set.
Quick breakdown:
* Invocation: The filterâ€™s doFilter runs on every request.
* When it attempts auth: Only if requestMatcher.matches(request) â†’ typically your /rest/login POST.
* SecurityContext check: None by default. If the request is the login URL, it will still attempt authentication even if SecurityContext already has an Authentication.
* Contrast with token filters: Filters like BearerTokenAuthenticationFilter usually skip if SecurityContext already contains an authenticated principal.
Practical tip for your setup:
* Make sure your custom token filter skips /rest/login, and let UsernamePasswordAuthenticationFilter handle just the login endpoint. This avoids redundant or conflicting authentication logic on the same request.

Decorator (Facade).of -> SpecificDecorator

Delegator.of().SpecificDelegator

Builder vs Decorator/Delegator
