
Gradle + GitLab CI/CD Testing
Checkstyle 

- [ ] AssertUtil design
- [ ] 整理电脑上的资源
- [ ] !!!!!!!! Every month need submit timesheet by 20th of every month during the internship period.

IHP Guideline Internet exploration. (Heath Concierge)



System Analysis
Business Requirement Document
Technical Risk Review

Development Process (the SOP & Tools & Validating Logic) -> How to adapt to the changes?  TDD pain points - design change, or evolving logic.





Concurrency - How if I know the current threads/ virtual thread available in the JVM (especially when using a framework like SpringBoot)? When virtual threads can be used (both IO and CPU or only IO)? How it can be fast? What’s the mechanism of the Virtual Thread?

Danger	Why It Hurts
I/O-bound logic (DB/API calls)	Threads block; hurts performance
You mutate shared state	Introduces race conditions unless synchronized
You need predictable order (e.g., LinkedHashSet)	Parallel streams lose ordering guarantees
You're running inside Servlet containers (Tomcat, etc.)	CommonPool can starve other threads unless isolated

Multiple pool how they works together )especially when using own pool isolated from the global pool especially in a web container?

Write a CompletableFuture + ThreadPool 
Course Design + Performance Checking + Testing (JVM + SpringBoot) + WIF3011 

IO-based

Domain Knowledge (程序员的能力衡量）
Solution Planning
深入学习 ifastpay repository, 学习优秀的，重构值得重构的，然后引入 GitLab 等机制，顺便学习领域知识（PlantUML if not provided, else use theirs to study）+ 常见算法

代码写法 & 设计（如何写出好的代码）
领域知识
常见算法 & 设计方式（AssertUtil， Validators）
架构设计
底层知识学习

当我觉得做某件事很无聊的时候，可以多记录，大脑发散思维特别厉害。我是一个需要在纸上才能进行思考的人来（因为我不喜欢记忆，如果需要记忆的话我就会变笨了 ；））

把自己当成 Problem Solver 而不是 Junior/Senior Developer；Title 和薪水是为了匹配我当前解决问题的能力而不是看我做什么事。尝试去解决最困难的问题 —— 代码、组织、文化，成为那个 Plug-and-Play 的人，因为公司没有理由需要培养你成为他们的一部分。做出筛选永远比培养更有效，最是符合经济效应。

你把 AI 当成一个很聪明的人，可是他对文化一窍不通，也无法理解相关语境和权衡 —— 除非你告诉他。除非哪一天 AI 拥有了真正了解某种文化而并非实名去写，那人类程序员才会有被替代的一天 —— 但我相信，这一天还是相对遥远，因为如果真的有那么一天，消失的会是整个人类文明。


非功能性需求 & 优化
程序员的主动能力

Jimmy - Yu Xuan - Chloe - Wei Li, Michael Yess, Ying Ying, Kyzo, Me (Eng Ian on leave)

GitLab Wiki vs Current Design 目前学习文化的问题
- 没有相关底层提升的东西，更多是“复用” 和规范的问题，但是没有明显的整理；Illuminator 本身没有 Folder 吗？为什么每个 Project 之间要进行隔离？为什么不要使用 Wiki？

生活与工作的融合

为什么网上会在批判资本家？为什么这不可是一个互惠互利的过程而一定是 “我单方面输出” 的过程？什么是牛马？什么是加班？

Record + Builder (Allowing null value). If want optional value, then class. .With (wither usage (Clone + change some place) - immutable data model
- https://github.com/Randgalt/record-builder
- https://projectlombok.org/features/With
- https://projectlombok.org/api/lombok/package-summary




B2B, B2C, B2B2C (Fintech solution)


https://docs.oracle.com/en/java/javase/20/core/virtual-threads.html#GUID-144A9694-40FD-4F63-97D2-8D394450F5D2

How to focus on testing (input, expecting handling)? Then the other delegates to the proper tools?

iFast design spec reference
Markdown + Table + PlantUML (real time preview)
Why not use PlantUML?





Investment product
Funds, bonds, stocks & EPFs. Insurance, online managed portfolios (DPMS), fintech solutions, cash management solutions, pension administration, banking


防御性编程的思考（什么人需要防御性编程？为什么我们需要防御性编程？是否有更高维度的手段去达到防御性编程背后想要达到的目的？为什么大家在博弈之下都会选择防御性编程？）对老板来说，都是打工人，不好用就换；对程序员来说，何尝不是如此？我们要选择成长环境、风气都和我们适配的团队 —— 团队和公司文化也很重要。我目前的是？代码审核

Root project run
- Does it run per build or each time I run a plugin? If the build, it doesn’t; match my need.

- Run it from the aggregated root, and make the each tasks be able to load it. Extract out the common logic since the only difference is running from which root & the current working directory only

现在的问题：
Gradle File - 1:41:24, 12:30
- [x] Duplicated line，可能是重复跑了好几次，需要再 Debug 过 
- [ ] 可以的话就 extract out common logic 减少需要重复跑（caching） from aggregate line
- [x] Fix problem where for aggregate line should filter (Already got)
- [x] 现在是用错的 projectDir 在跑 git，需要改
    - [ ] 处理方式是接受一个 parameter for determining the value of the working repository, but the question is why when I register it under the subproject modules but yet it will still using the root project directory? Why it behaves it that way?

When see gray colour in Gradle don’t give it a fuck unless it still gray after you have run and refresh the Gradle script


工作模式
- 随时开着笔记 + 随时记录，不需要管是否有条理，就是本日记录，然后需要整理的时候再创建 Hyperlink 连过去成为某种证明就可以了；如果没有整理好就不要移动了（只能从缓存区到实体区） - Context Saving

看到了什么也随时记录一下，不需要多么高大上，重点是要多记录，保存知识，保存有用的信息，也可以随时写下自己的想法，让灵感源源不断源源不绝。也可以写下当前 Blocker 和问题，还有解决思路。把这些写清楚了那就可以去审视这个流程究竟是否有问题，也可以确保自己的处事行为是清楚明晰明了的。



Real time note taker
- 只能往下记录（保持凌乱）且不能修改，重点是要多记录，保持流失创作；之后才是导出 + 整理。


Gradle 7.3 has no memoized function so we have to use lazy initialisation + singleton pattern in gradle script for caching a provider. A provider is similar to a supplier, so without caching or memoization function, it will repeatedly call those expensive supplier function resulting in performance degradation and noise output. So we need to cache those results to keep everything clear and compute only once. Paste code later


Big problems come from small problems, so the main idea is to break large problems to small problems (make sure it’s small enough to be solved) and solve them one by one. Your confident build when you solve issues and get to the direction, and when you solve small issues, you will know more why  instead of getting only a vague impression of what you are currently doing right now. Such idea of learning slowly give a flow of study which makes you feel happier and your skills grow during the process.


和 AI 交流的模式：
描述问题，提供情景（比如错误日志，异常情况）和更具体的描述，然后说出你的Expected Behaviour，然后请他提供可能的 causes + 解决方法。你目前的努力（文件、改动），还有一些其他补充信息

模版
Problem Duplicated log files
Description: A provided in the following log file, I found that the checkstyleStaged log are repeated for multiple times, and I suspect that there’s a repeated call of the related functions.

Expected Outcome: The log.lifecycle will only output once instead of multiple times, as follows:
“””
“””
Current Works: Refer to the build.gradle file in the attachment
Contexts: SpringBoot 3.5, build.gradle 7.3, multimode project - 
-
-
Attachment: build.gradle script

这个模版可以在之后补上下面这些 Fields
- Causes: The provider is like a supplier….
- Solutions: In higher version (8.*), we can use .memoized to cache the value, but for older versions and backward compatibility, we should use a singleton-like approach.
- Conclusion：通用解题思维
    - Provider:
    - Memoization:
- Further questions
    - What’s the mechanism of the only if (like the flow they are being executed?) 

这就是一个完整的学习模版了

Problem:
Description: 
Expected Outcome: 
Current Works: Refer to the build.gradle file in the attachment
Contexts: SpringBoot 3.5, build.gradle 7.3, multimode project

Problem Template
Problem: To confirm the feasibility of extracting out an inline function in Gradle.Groovy script
Description: In the subproject > task.register(“checkstyleStaged”) fields, I wish I could take the executeCommands out and put in in the root for reusability across other tasks. Is it feasible?
Expected Outcome: The executeCommand is extracted out and put in the root.
Current Works: Refer to the build.gradle file in the attachment
Contexts: SpringBoot 3.5, build.gradle 7.3, multimode project 
Inquiry Template
What: Can I move the executeCommands to the root gradle script?
Why:
Current Works: Refer to the build.gradle file in the attachment
Contexts: SpringBoot 3.5, build.gradle 7.3, multimodule project
Why:
How:

What: Can I move the executeCommands to the root gradle script? Why: I wish I could reuse the executeCommands across different tasks. Current Works: Refer to the build.gradle file in the attachment Contexts: SpringBoot 3.5, build.gradle 7.3, multimode project

What: Where can I place the executeCommands? Why: I wish I could keep it clean and neat. Current Works: build.gradle Contexts: SpringBoot 3.5, build.gradle 7.3, multimode project

ext.executeCommands = { List<String> cmd, File dir = rootProject.projectDir ->
    def proc = new ProcessBuilder(cmd).directory(dir).redirectErrorStream(true).start()
    proc.waitFor()
    proc.exitValue() == 0 ? proc.inputStream.text.trim() : ""
}

def out = rootProject.ext.executeCommands(['git', 'rev-parse', '--short', 'HEAD'])


buildSrc/
└─ src/main/groovy/
   └─ util/ExecUtil.groovy

// ExecUtil.groovy
package util
import org.gradle.api.Project

class ExecUtil {
    static String run(Project p, List<String> cmd, File dir = p.rootProject.projectDir) {
        def proc = new ProcessBuilder(cmd).directory(dir).redirectErrorStream(true).start()
        proc.waitFor()
        proc.exitValue() == 0 ? proc.inputStream.text.trim() : ""
    }
}


import util.ExecUtil
def diff = ExecUtil.run(project, ['git', 'diff', '--name-only'])

build-logic/
└─ src/main/groovy/
   └─ com/acme/git/ExecPlugin.groovy

// build-logic/src/.../ExecPlugin.groovy
package com.acme.git
import org.gradle.api.Plugin
import org.gradle.api.Project

class ExecPlugin implements Plugin<Project> {
    void apply(Project p) {
        p.ext.execGit = { List<String> cmd, File dir = p.rootProject.projectDir ->
            def proc = new ProcessBuilder(cmd).directory(dir).redirectErrorStream(true).start()
            proc.waitFor()
            proc.exitValue() == 0 ? proc.inputStream.text.trim() : ""
        }
    }
}

pluginManagement {
    includeBuild("build-logic")          // makes the plugin visible
}



What: Where can I place the ext block? After subprojects, before subprojects, or is there any better way? Why: I wish I could keep it clean and neat. Current Works: build.gradle Contexts: SpringBoot 3.5, build.gradle 7.3, multimode project

Placement	Works?	Readability / best-practice	Why
Top-level, right after plugins { … }	✅	Recommended – all constants & helpers are declared once up-front, before they’re referenced by subprojects / allprojects.	Keeps “global constants” at the top, just like import/plugins.
Inside allprojects { … }	✅	Acceptable, but the file can feel crowded because the block mixes constants with common configuration.	Still visible to every sub-project, but harder to spot.
Inside subprojects { … }	✅ (for sub-projects) – ❌ (for the root project itself)	Not ideal. The root project can’t see the property unless you repeat it elsewhere.	Scopes the property only to sub-modules.
End of the file (after subprojects)	✅	Technically fine, but anyone reading the build has to scroll to the bottom to find shared constants.	Gradle evaluates root build.gradle top-to-bottom before applying sub-project scripts, so the timing still works.


In Gradle 7.3, Groovy DSL no longer allows you to access ext directly as a property like rootProject.ext inside a closure or method context, unless it's a script-level property. That's why you're seeing:

Instead of 
def exec = rootProject.ext

Use
def exec = rootProject.extensions.extraProperties

def executeCommands = rootProject.extensions.extraProperties.get('executeCommands')

 不要过度记录




5:50p.m., 2:42:09

# .gitlab/ci_templates/checkstyle.gitlab-ci.yml
stages:
  - validate

checkstyle:
  stage: validate
  tags:
    - my-ifast-pay-build-rke2
  image: gradle:jdk21
  allow_failure: true
  variables:
    GRADLE_USER_HOME: .gradle
    GIT_STRATEGY: fetch
    GIT_DEPTH: 0
  interruptible: true
  script:
    - |
      if [ -n "$CI_MERGE_REQUEST_TARGET_BRANCH_SHA" ]; then
        BASE="$CI_MERGE_REQUEST_TARGET_BRANCH_SHA"
      else
        BASE="origin/${CI_DEFAULT_BRANCH:-master}"
        git fetch --no-tags --prune origin "${CI_DEFAULT_BRANCH:-master}" || true
      fi
      CHANGED="$(git diff --name-only --diff-filter=ACMRTUXB "$BASE" "$CI_COMMIT_SHA" -- ':(glob)**/*.java')"
      if [ -z "$CHANGED" ]; then
        echo "No changed Java files."
        exit 0  # cleanly skip job (no artifacts)
      fi
      echo "Changed Java files: $CHANGED"
      gradle --no-daemon -Pfiles="$CHANGED" checkstyleStaged
    - echo "Checkstyle output:"
    - find . -type f -name "*.html" -path "*/reports/*"
  cache:
    key: "$CI_PROJECT_ID-$CI_COMMIT_REF_SLUG-gradle-checkstyle"
    policy: pull-push
    paths:
      - .gradle/caches
  artifacts:
    when: always
    expire_in: 1 hour
    paths:
      - '**/build/reports/checkstyle/'
  rules:
    - if: '$CI_COMMIT_BRANCH == "feature/checkstyle" && $CI_PIPELINE_SOURCE == "push"'
      when: on_success





buildSrc/src/main/groovy/com/ifastpay

package com.ifastpay

import org.gradle.api.Project

class GitUtils {

    private GitUtils() {
    }

    static String executeCommand(List<String> cmd, Project requester) {
        def workingDir = requester.projectDir
        def logger = requester.logger

        try {
            logger.info("[exec] ${cmd.join(' ')} (cwd=${workingDir})")
            def proc = new ProcessBuilder(cmd)
                    .directory(workingDir)
                    .redirectErrorStream(true)
                    .start()
            proc.waitFor()
            return proc.exitValue() == 0 ? proc.inputStream.text.trim() : ""
        } catch (Exception e) {
            logger.warn("[exec] failure: ${e.message}")
            return ""
        }
    }

    static String gitDiffJava(List<String> extraArgs = [], Project requester) {
        def cmd = ['git', 'diff', '--name-only', '--diff-filter=ACMRTUXB'] +
                extraArgs +
                ['--', ':(glob)**/*.java']
        return executeCommand(cmd, requester)
    }

    static void gitFetchBranch(String remote = 'origin', String branch, Project requester) {
        executeCommand(['git', 'fetch', '--no-tags', '--prune', remote, branch], requester)
    }
}


package com.ifastpay

import org.gradle.api.Project

class StagedFileUtils {

    private StagedFileUtils() {
    }

    static String detectStagedJavaFiles(Project project) {
        def logger = project.logger

        // Priority 1: User manually provides files via -Pfiles
        def filesOverride = project.providers.gradleProperty('files').orElse('').get().trim()
        if (filesOverride) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] Using -Pfiles override")
            return filesOverride.replaceAll(/\s+/, '\n')
        }

        // Priority 2: GitLab CI/CD Merge Request context
        def env = System.getenv()
        def baseSha = env['CI_MERGE_REQUEST_TARGET_BRANCH_SHA']
        def headSha = env['CI_COMMIT_SHA']
        def defaultBranch = env['CI_DEFAULT_BRANCH'] ?: 'develop'

        if (baseSha && headSha) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] GitLab MR context detected: ${baseSha}..${headSha}")
            def output = GitUtils.gitDiffJava([baseSha, headSha], project)
            if (output) {
                logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${output.readLines().size()} Java file(s) in GitLab MR diff")
                return output
            }
        }

        // Priority 3: CI/CD Pipeline
        if (env['CI'] == 'true') {
            logger.lifecycle("[checkstyleStaged] [${project.path}] CI pipeline context – comparing against origin/${defaultBranch}")
            GitUtils.gitFetchBranch('origin', defaultBranch, project)
            def output = GitUtils.gitDiffJava(["origin/${defaultBranch}", "HEAD"], project)
            if (output) {
                logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${output.readLines().size()} Java file(s) in CI diff against ${defaultBranch}")
                return output
            }
        }

        // Priority 4: Local development (interactive staging)
        def stagedFiles = GitUtils.gitDiffJava(['--cached'], project)
        if (stagedFiles) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${stagedFiles.readLines().size()} staged Java file(s)")
            return stagedFiles
        }

        // Priority 5: Local development - if no staged files, check unstaged changes
        def unstagedFiles = GitUtils.gitDiffJava([], project)
        if (unstagedFiles) {
            logger.lifecycle("[checkstyleStaged] [${project.path}] Found ${unstagedFiles.readLines().size()} unstaged Java file(s)")
            return unstagedFiles
        }

        logger.lifecycle("[checkstyleStaged] [${project.path}] No Java files found for checkstyle analysis")
        return ""
    }
}

稍微来复盘一下今天后半段的时间都在干些什么吧。早上的话主要是在处理那些问题嘛，比如 Repeated calls 和 Project Directory incorrectly set 这两个问题。前者是因为我的 script 一开始是返回 Provider，所以每次都会重复调用 Provider 造成大量 Logging + 效率低下。后来尝试使用 。memoized 但由于我用的版本是 7.3 所以不配使用，最后是用了 singleton-like 的处理方式去做到 cache，算是解决了这个问题；后者则是一开始设置 project。projectDir 其实是没有用的，因为设置应该是在 root 哪里，所以传进去的数值会是 root 的 dir，导致每次都无法正确找到文件导致报错。解决方式就是把通过外部传参数去执行这个 directory，不仅解决了问题，还提高了灵活性，方便之后的 Refactoring。

代码是写好了，但是我想着这样的效率不够高，因为每次都要用 Git 拿请求，特别麻烦，所以想着如果是从 root 那里执行这个任务的话就直接跑一次，之后的任务就是从里面获取就可以了，于是就探索了如何把方法定义在外面，目前使用的策略是 ext，到时候可以通过 rootProject.extensions.extraProperties./ .get() 获取相关的 function 或者数值，但这个过程也没那么简单，因为 gpt 给我的是 。ext 简单的三个字，这些都是我后来自己研究和摸索和报错里面测试出来的。

一开始是把先把 executeCommands 丢了出去，然后再逐步增加其他 method，比如 gitDiffJava 减少之后引用的麻烦。然后我就碰到了两个问题：
1. Type casting：由于 ext 收东西都是 return object，但是我不知道这一点，所以一直在鬼打墙；后来才不想了直接上 as Provider<String>;  如果是 ternary operator 的话那要确保两个都 cast 对。
2. Type casting 引申出的第二个问题是 inputs.files  和 sources 这部分到底要引入什么，后来还是接着不懂是 claude 还是 gpt 解决了这个问题，反正都是用 lazy evaluation 的  「期间顺手解决了 output.upToDateWhen 的问题，也就是解决了 checkstyle 懒惰不干活（checkstyle 会看里面的内容是不是旧的，旧的就默认跳过；这个设置就是说不管新的旧的你都要强制执行）。
3. 为了解决那个 Repeated calles 我也是引入了 getStagedJavaFiles() 这个东西，真的是煞费苦心。。。gpt 大概也是被逼急了直接不断忘记他提供给我的解法 ；）期间也删除了很多我认为是 noise 的 log，还学到了关于 log 的小知识（lifecycle & info）
4. 因为要做到全局缓存，所以那个 root 的任务我也写了一个很丑的 if-else。。。
5. 其实原本的第二个问题我也不是很清楚是什么了，不过应该是全局缓存？全局缓存的问题就是要如何正确 setting + type casting + 不要忘记 project-based cache，反正什么不懂都可以 refer 回上面的。

之后的话是研究 Groovy，这里也是多灾多难，起初是觉得目前的 Gradle Script 有点丑，毕竟所有的逻辑都耦合在一起，所以我想把它们分开成不同的文件，按需导入。一开始尝试的方法是 用 gradle/XXX.gradle 但不知道为什么全部灰色，大概率是导入不进去了，所以摆在我面前的只有两个方法：一个是用 Groovy，另外一个就是 Plugin。我看了看 Groovy 相对来说好上手，所以我就选择了 Groovy。

Groovy 的话一开始的问题是完全不知道要怎么配置，然后就踩了很多坑，比如
1. 把 package name 设定成 com.ifastoay, 但实际上应该是 com/ifastpay 后者才是标准的包名写法，前者只是后者的简写而已（哭 我已经走投无路被逼无奈了
2. 第二就是我没有放 build.gradle，所以我的 主 GRadle 并不能识别这是一个正确的 module/package，导致我的代码（一开始是 GitOperationsService 和 StagedFilesDetector）要么是灰色，不然就是 hover 过去的时候给我显示 Object，心都凉了一半。后来是导入了下面的 build.gradle  然后重新build 过一次之后就好了
3. 第三个问题就是没有给每个类设定 package name 导致无法正确 import，其实这是因为第二个问题导致我没办法即时更新（IDE 无法自行判断）。有了 build.gradle  之后这些问题就都解决了。

后来就是改一下 Groovy scripts 使用 Project instead of project dir 提供更多的 flexibility，也更好地和之前的 code 做 integration，之后测试了一轮（root + package）都可以正常跑！

plugins {
    id 'groovy'              // gives you compileGroovy etc.
}

repositories {
    mavenCentral()           // where Groovy lives
    gradlePluginPortal()     // optional, if you pull Gradle plugins
}

dependencies {
    implementation gradleApi()   // Gradle types for your helpers
    implementation localGroovy() // Groovy that ships with your Gradle
}


最后是 yml 的配置

最后的话是 yml 配置，老实说着就比较简单了，主要的话就是改了 CICD 文件让他
- 不要 fail pipeline（allow_failure: true）
- 让他不要把 newline 转换成 comma（tr ‘\n’, ‘,’ 而已，剩下的都能正常运行。目前他是会拿 develop 和自己的 branch 进行比对，一切顺利

# .gitlab/ci_templates/checkstyle.gitlab-ci.yml
stages:
  - validate

checkstyle:
  stage: validate
  tags:
    - my-ifast-pay-build-rke2
  image: gradle:jdk21
  allow_failure: true
  variables:
    GRADLE_USER_HOME: .gradle
    GIT_STRATEGY: fetch
    GIT_DEPTH: 0
  interruptible: true
  script:
    - |
      if [ -n "$CI_MERGE_REQUEST_TARGET_BRANCH_SHA" ]; then
        BASE="$CI_MERGE_REQUEST_TARGET_BRANCH_SHA"
      else
        BASE="origin/${CI_DEFAULT_BRANCH:-master}"
        git fetch --no-tags --prune origin "${CI_DEFAULT_BRANCH:-master}" || true
      fi
      CHANGED="$(git diff --name-only --diff-filter=ACMRTUXB "$BASE" "$CI_COMMIT_SHA" -- ':(glob)**/*.java')"
      if [ -z "$CHANGED" ]; then
        echo "No changed Java files."
        exit 0  # cleanly skip job (no artifacts)
      fi
      echo "Changed Java files: $CHANGED"
      gradle --no-daemon -Pfiles="$CHANGED" checkstyleStaged
    - echo "Checkstyle output:"
    - find . -type f -name "*.html" -path "*/reports/*"
  cache:
    key: "$CI_PROJECT_ID-$CI_COMMIT_REF_SLUG-gradle-checkstyle"
    policy: pull-push
    paths:
      - .gradle/caches
  artifacts:
    when: always
    expire_in: 1 hour
    paths:
      - '**/build/reports/checkstyle/'
  rules:
    - if: '$CI_COMMIT_BRANCH == "feature/checkstyle" && $CI_PIPELINE_SOURCE == "push"'
      when: on_success


